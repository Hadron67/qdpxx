<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>QDP++</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<style type="text/css"> code{ font-size: 130% } </style>
</head>
<body>
<center>
<b>QDP++  User Guide: &nbsp;</b>
<a class="qindex" href="index.html">Front Page</a> &nbsp;
<a class="qindex" href="intropage.html">Introduction</a> &nbsp;
<a class="qindex" href="datatypespage.html">Data Types</a> &nbsp;
<a class="qindex" href="qdpfuncpage.html">Functions</a> &nbsp;
<a class="qindex" href="simpleiopage.html">Simple IO</a> &nbsp;
<a class="qindex" href="qiopage.html">Record IO</a>&nbsp; 
<a class="qindex" href="buildpage.html">Compilation</a> &nbsp; 
<a class="qindex" href="spinpage.html">Spin Conventions</a> &nbsp; 
<a class="qindex" href="impldetail.html">Implementation</a> 
</center>
<hr>
<!-- Generated by Doxygen 1.8.2 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">QDP Record I/O utilities} </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="secqio"></a>
QDP Record I/O utilities</h1>
<p>The record IO code in QDP is a C++ wrapper of QIO, QIO is a C library independent of QDP. It is designed to write SciDAC format data files, which means a mixture of binary data and XML metadata bundled together in the same file according to a scheme called Lime. QIO itself is discussed in more detail in the <a class="el" href="qiodetailpage.html">QIO internals</a> section.</p>
<p>The QDP code described in this section is documented in the qio section of the Reference Manual.</p>
<ol type="1">
<li><a class="el" href="qiopage.html#secfileformat">Overview of File Format</a></li>
<li><a class="el" href="qiopage.html#qioapi">QDP/C++ Record API</a></li>
</ol>
<h2><a class="anchor" id="secfileformat"></a>
Overview of File Format</h2>
<h3><a class="anchor" id="binaryqdp"></a>
Binary QDP Files</h3>
<p>The binary file format has been designed with flexibility in mind. For archiving purposes, the allowable file organization may be further restricted. Here we described the unrestricted format.</p>
<p>Two classes of file volumes are supported: single-file volumes and multiple-file volumes. In the latter case lattice data is scattered among several files for distributed reading and writing. In the former case all the lattice data is contained in a single file.</p>
<dl class="section user"><dt>Single file format</dt><dd></dd></dl>
<p>Single binary QDP files are composed of a series of one or more application records. A single application record encodes a single QDP field or an array of QDP fields of the same data type. Physics metadata, managed at the convenience of the applications programmer, is associated with the file itself and with each application record as well. Above the API the QDP file is viewed as follows:</p>
<ul>
<li>File physics metadata</li>
<li>Record 1 physics metadata and data</li>
<li>Record 2 physics metadata and data</li>
<li>etc.</li>
</ul>
<p>For example, a file might record a series of staggered fermion eigenvectors for a gauge field configuration. Each record would map to a single field of type LatticeColorVector. The file metadata might include information about the gauge field configuration and the record metadata might encode the eigenvalue and an index for the eigenvector.</p>
<p>For another example, the gauge field configuration in four dimensions is represented in QDP as an array of four color matrix fields. The configuration is conventionally written so that the four color matrices associated with each site appear together. A file containing a single gauge field configuration would then consist of a single record containing the array of four color matrices.</p>
<p>The API permits mixing records of different datatypes in the same file. While this practice may be convenient for managing projects, it may be forbidden for archival files.</p>
<p>Additional metadata is automatically managed by QIO (without requiring intervention by the applications programmer) to facilitate the implementation and to check data integrity. Thus the file actually begins with QIO metadata and physics metadata and each application record consists of five logical records. Within QIO the file is viewed as a series of logical records as follows:</p>
<ul>
<li>Private file QIO metadata</li>
<li>User file physics metadata</li>
<li>Record 1 private QIO metadata</li>
<li>Record 1 user physics metadata</li>
<li>Record 1 binary data</li>
<li>Record 1 private checksum</li>
<li>Record 2 private QIO metadata</li>
<li>Record 2 user physics metadata</li>
<li>Record 2 binary data</li>
<li>Record 2 private checksum</li>
<li>etc.</li>
</ul>
<p>The site order of the binary data is lexicographic according to the site coordinate <em>r<sub>i</sub></em> with the first coordinate <em>r<sub>0</sub></em> varying most rapidly.</p>
<p>A format called LIME (Lattice-QCD Interchange Message Encapsulation) is used for packaging the logical records. A feature of this format is the maximum record size is quite large - <em>2<sup>64</sup>-1</em> bytes. However, file system limitations may require splitting a single file into multiple physical files. No provision is provided for such splitting. It is expected that in time file systems will evolve to allow much larger file sizes. In the interim, facilities like <em>cpio</em> and <em>tar</em> can be used for file splitting.</p>
<dl class="section user"><dt>Multifile format</dt><dd></dd></dl>
<p>The API provides for rapid temporary writing of data to scratch disks and reading from scratch disks. This same format may be used for staging files for access by many compute nodes. In this case it is assumed that the files are not intended for longer term storage. Thus the file format in this case is implementation-dependent and not standardized. A specific choice of format is described in the Appendix.</p>
<h3><a class="anchor" id="metadata"></a>
ASCII Metadata Files</h3>
<p>The API also provides for reading and writing global values in a standard metadata format from or to a file or a stream buffer. Startup parameters for controlling a simulation could be read in this way. Results of a computation could be written in this way for post processing and analysis.</p>
<p>The XML I/O facilities described in Section <a class="el" href="simpleiopage.html#secxmlio">XML Reading and Writing</a> are used for manipulating the metadata.</p>
<h2><a class="anchor" id="qioapi"></a>
QDP/C++ Record API</h2>
<p>As with standard Unix, a file must be opened before reading or writing. However, we distinguish file handles for both cases. If the system provides a parallel file system, it is possible for several processors to read and write a single file. We call this mode "parallel". Otherwise the file is read by a single processor and the data delivered according to the distributed memory layout. The reverse occurs upon writing. We call this mode "serial". To allow user choice where the architecture permits, we provide for requesting either mode. However, the request may be overridden if the system permits only one mode. Upon writing, we allow appending to an existing file.</p>
<dl class="section user"><dt>QDPFileWriter class member functions and global functions</dt><dd></dd></dl>
<p>QDPFileWriter ia a concrete class for all QDPIO write operations.</p>
<ul>
<li>Open<ul>
<li>QDPFileWriter::QDPFileWriter(const XMLBufferWriter&amp; file_xml, const std::string&amp; path, QDP::QDP_volfmt_t volfmt, QDP::QDP_serialparallel_t serpar, QDP::QDP_filemode_t mode)</li>
<li>void QDPFileWriter::open(const XMLBufferWriter&amp; file_xml, const std::string&amp; path,</li>
<li>void QDPFileWriter::open(const XMLBufferWriter&amp; file_xml, QDP::QDP_volfmt_t volfmt, QDP::QDP_serialparallel_t serpar, QDP::QDP_filemode_t mode)</li>
</ul>
</li>
<li>Close<ul>
<li>QDPFileWriter::~QDPFileWriter()</li>
<li>void QDPFileWriter::close()</li>
</ul>
</li>
<li>Open?<ul>
<li>bool QDPFileWriter::is_open()</li>
</ul>
</li>
<li>Errors?<ul>
<li>bool QDPFileReader::bad()</li>
</ul>
</li>
<li>Write a T<ul>
<li>void write(QDPFileWriter&amp;, XMLBufferWriter&amp; rec_xml, const T&amp;)</li>
</ul>
</li>
<li><p class="startli">Array of T</p>
<ul>
<li>void write(QDPFileWriter&amp;, XMLBufferWriter&amp; rec_xml, const multi1d&lt;T&gt;&amp;)</li>
</ul>
<p class="startli">Here, QDP::write writes the sites as the slowest varying index and the array (multi1d) indices inside of them. QDPFileReader::bad states if any fatal errors have occurred. The <em>volfmt</em> argument is one of</p>
</li>
</ul>
<pre class="fragment">  QDPIO_SINGLEFILE, QDPIO_MULTIFILE, QDPIO_PARTFILE
</pre><p>The serpar argument is one of </p>
<pre class="fragment">  QDPIO_SERIAL, QDPIO_PARALLEL
</pre><p>and the mode argument is one of</p>
<pre class="fragment">  QDPIO_CREATE, QDPIO_OPEN, QDPIO_APPEND
</pre><p>where QDP::QDPIO_CREATE fails if the file already exists, QDP::QDPIO_OPEN overwrites the file if it already exists and creates it if not, and QDP::QDPIO_APPEND fails if the file does not exist and otherwise appends at the end of the file. When appending, the file metadata argument is ignored, since it should already exist.</p>
<dl class="section user"><dt>QDPFileReader class member functions and global functions</dt><dd></dd></dl>
<p>QDPFileReader is a concrete class for all QDPIO read operations.</p>
<ul>
<li>Open<ul>
<li>QDPFileReader::QDPFileReader(XMLReader&amp; file_xml, const std::string&amp; path, QDP::QDP_serialparallel_t serpar)</li>
<li>void QDPFileReader::open(XMLReader&amp; file_xml, const std::string&amp; path, QDP::QDP_serialparallel_t serpar)</li>
</ul>
</li>
<li>Close<ul>
<li>QDPFileReader::~QDPFileReader()</li>
<li>void QDPFileReader::close()</li>
</ul>
</li>
<li>Open?<ul>
<li>bool QDPFileReader::is_open()</li>
</ul>
</li>
<li>EOF?<ul>
<li>bool QDPFileReader::eof()</li>
</ul>
</li>
<li>Errors?<ul>
<li>bool QDPFileReader::bad()</li>
</ul>
</li>
<li>Read a T<ul>
<li>void read(QDPFileReader&amp;, XMLReader&amp; rec_xml, T&amp;)</li>
</ul>
</li>
<li>Array of T<ul>
<li>void read(QDPFileReader&amp;, XMLReader&amp; rec_xml, multi1d&lt;T&gt;&amp;)</li>
</ul>
</li>
</ul>
<p>Here, read(QDPFileReader&amp;, XMLReader&amp;, multi1d&lt;T&gt;&amp;) expects in the binary file that the sites are the slowest varying index and the array indices (multi1d) inside of them. The QDP::QDP_volfmt_t <em>volfmt</em> argument is not needed - a file in either QDP::QDPIO_SINGLEFILE or QDP::QDPIO_MULTIFILE format will be automatically detected and read appropriately. There are no user functions that position within a logical record.</p>
<p>Here is an example of how to use the record I/O facility.</p>
<pre class="fragment">XMLBufferWriter file_xml;
QDPFileWriter out(file_xml, "foo", QDPIO_SINGLEFILE, 
                  QDPIO_SERIAL, QDPIO_OPEN);
XMLBufferWriter rec_xml;
LatticeColorMatrix a;
write(out, rec_xml, a);
write(out, rec_xml, a);  // for fun, write field twice
close(out);

QDPFileReader in(file_xml, "foo", QDPIO_SERIAL);
read(in, rec_xml, a);
skip(in);
close(in);
</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 23 2014 15:12:06 for QDP++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
