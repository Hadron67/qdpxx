<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>QDP++</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<style type="text/css"> code{ font-size: 130% } </style>
</head>
<body>
<center>
<b>QDP++  User Guide: &nbsp;</b>
<a class="qindex" href="index.html">Front Page</a> &nbsp;
<a class="qindex" href="intropage.html">Introduction</a> &nbsp;
<a class="qindex" href="datatypespage.html">Data Types</a> &nbsp;
<a class="qindex" href="qdpfuncpage.html">Functions</a> &nbsp;
<a class="qindex" href="simpleiopage.html">Simple IO</a> &nbsp;
<a class="qindex" href="qiopage.html">Record IO</a>&nbsp; 
<a class="qindex" href="buildpage.html">Compilation</a> &nbsp; 
<a class="qindex" href="spinpage.html">Spin Conventions</a> &nbsp; 
<a class="qindex" href="impldetail.html">Implementation</a> 
</center>
<hr>
<!-- Generated by Doxygen 1.8.2 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Implementation Details </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="secimplementation"></a>
Implementation Details</h1>
<ol type="1">
<li><a class="el" href="impldetail.html#headerfiles">Header Files</a></li>
<li><a class="el" href="impldetail.html#secsupported">Supported Operations</a></li>
<li><a class="el" href="impldetail.html#secsubsets">Subsets and Maps</a></li>
<li><a class="el" href="impldetail.html#secinfix">Infix operators</a></li>
<li><a class="el" href="impldetail.html#seccfuncs">Functions</a></li>
<li><a class="el" href="impldetail.html#secfuncs">Additional functions (specific to QDP)</a></li>
<li><a class="el" href="impldetail.html#secinplace">In place functions</a></li>
<li><a class="el" href="impldetail.html#secbroadcasts">Broadcasts</a></li>
<li><a class="el" href="impldetail.html#secreductions">Global reductions</a></li>
<li><a class="el" href="impldetail.html#secglobalcomparisons">Global comparisons</a></li>
<li><a class="el" href="impldetail.html#secpeek">Accessors</a></li>
<li><a class="el" href="impldetail.html#secotherfuncs">More exotic functions</a></li>
<li><a class="el" href="impldetail.html#subtypeops">Operations on subtypes</a></li>
</ol>
<h2><a class="anchor" id="headerfiles"></a>
Header Files</h2>
<p>The following table lists some of the QDP headers.</p>
<ul>
<li>qdp.h<ul>
<li>Master header and QDP utilities</li>
</ul>
</li>
<li>qdp_qdptype.h<ul>
<li>Main class definition</li>
</ul>
</li>
<li>qdp_qdpexpr.h<ul>
<li>Expression class definition</li>
</ul>
</li>
<li>qdp_primitive.h<ul>
<li>Main header for all primitive types</li>
</ul>
</li>
<li>qdp_primscalar.h<ul>
<li>Scalar primitive class and operations</li>
</ul>
</li>
<li>qdp_primmatrix.h<ul>
<li>Matrix primitive and operations</li>
</ul>
</li>
<li>qdp_primvector.h<ul>
<li>Vector primitive and operations</li>
</ul>
</li>
<li>qdp_primseed.h<ul>
<li>Seed (random number) primitive</li>
</ul>
</li>
<li>qdp_reality.h<ul>
<li>Complex number internal class</li>
</ul>
</li>
<li>qdp_simpleword.h<ul>
<li>Machine word-type operations</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="secsupported"></a>
Supported Operations</h1>
<p>This section describes in some detail the names and functionality for all functions in the interface involving linear algebra with and without shifts.</p>
<p>All QDP objects are of type QDPType, and QDP functions act on objects of this base class type. Unless otherwise indicated, operations occur on all sites in the specified subset of the target, often an assignment statement or object definition. The indexing of a QDPType returns an lvalue suitable for assignment (but not object definition). It is also used to narrow the lattice sites participating in a global reduction since the result of such a reduction is a lattice scalar, hence are independent of lattice sites.</p>
<p>Supported operations are listed below. Convention: prototypes are basically of the form:</p>
<pre class="fragment">QDPType  unary_function(const QDPType&amp;)
QDPType  binary_function(const QDPType&amp;, const QDPType&amp;)
</pre><h2><a class="anchor" id="secsubsets"></a>
Subsets and Maps</h2>
<ul>
<li>Set::make(const SetFunc&amp;)<ul>
<li>Set construction of ordinality num subsets. func maps coordinates to a coloring in [0,num)</li>
</ul>
</li>
</ul>
<ul>
<li>Map::make(const MapFunc&amp;)<ul>
<li>Construct a map function from source sites to the dest site.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="secinfix"></a>
Infix operators</h2>
<h3><a class="anchor" id="Unary"></a>
Unary</h3>
<p>e.g., <code>operator-</code> </p>
<ul>
<li>-<ul>
<li>negation</li>
</ul>
</li>
<li>+<ul>
<li>unary plus</li>
</ul>
</li>
<li>~<ul>
<li>bitwise not</li>
</ul>
</li>
<li>!<ul>
<li>boolean not</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="Binary"></a>
Binary</h3>
<p>e.g., <code>operator+</code> </p>
<ul>
<li>+<ul>
<li>addition</li>
</ul>
</li>
<li>-<ul>
<li>subtraction</li>
</ul>
</li>
<li>*<ul>
<li>multiplication</li>
</ul>
</li>
<li>/<ul>
<li>division</li>
</ul>
</li>
<li>%<ul>
<li>mod</li>
</ul>
</li>
<li>&amp;<ul>
<li>bitwise and</li>
</ul>
</li>
<li>|<ul>
<li>bitwise or</li>
</ul>
</li>
<li>^<ul>
<li>bitwise exclusive or</li>
</ul>
</li>
<li>&lt;&lt;<ul>
<li>left-shift</li>
</ul>
</li>
<li>&gt;&gt;<ul>
<li>right-shift</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="Comparisons"></a>
Comparisons</h3>
<p>Operations returning booleans, e.g., <code>operator&lt;</code> </p>
<ul>
<li>&lt;<ul>
<li>less than</li>
</ul>
</li>
<li>&lt;=<ul>
<li>less than or equal</li>
</ul>
</li>
<li>&gt;<ul>
<li>greater than</li>
</ul>
</li>
<li>&gt;=<ul>
<li>greater than or equal</li>
</ul>
</li>
<li>==<ul>
<li>equality</li>
</ul>
</li>
<li>!=<ul>
<li>inequality</li>
</ul>
</li>
<li>&amp;&amp;<ul>
<li>logical and</li>
</ul>
</li>
<li>||<ul>
<li>logical or</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="Assignments"></a>
Assignments</h3>
<p>e.g., <code>operator+=</code> </p>
<ul>
<li>=,</li>
<li>+=,</li>
<li>-=,</li>
<li>*=,</li>
<li>/=</li>
</ul>
<h3><a class="anchor" id="Ternary"></a>
Ternary</h3>
<ul>
<li>where(bool,arg1,arg2)<ul>
<li>the C ternary <code></code>? operator (bool) ? arg1 : arg2</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="seccfuncs"></a>
Functions</h2>
<p>As in the standard C mathematics library.</p>
<h3><a class="anchor" id="Unary"></a>
Unary</h3>
<ul>
<li>QDP::cos</li>
<li>QDP::sin</li>
<li>QDP::tan</li>
<li>QDP::acos</li>
<li>QDP::asin</li>
<li>QDP::atan</li>
<li>QDP::cosh</li>
<li>QDP::sinh</li>
<li>QDP::tanh</li>
<li>QDP::exp</li>
<li>QDP::log</li>
<li>QDP::log10</li>
<li>QDP::sqrt</li>
<li>QDP::ceil</li>
<li>QDP::floor</li>
<li>QDP::fabs</li>
</ul>
<h3><a class="anchor" id="Binary"></a>
Binary</h3>
<ul>
<li>QDP::ldexp</li>
<li>QDP::pow</li>
<li>QDP::fmod</li>
<li>QDP::atan2</li>
</ul>
<h2><a class="anchor" id="secfuncs"></a>
Additional functions (specific to QDP)</h2>
<h3><a class="anchor" id="Unary"></a>
Unary</h3>
<ul>
<li>QDP::adj<ul>
<li>hermitian conjugate (adjoint)</li>
</ul>
</li>
<li>QDP::conj<ul>
<li>complex conjugate</li>
</ul>
</li>
<li>QDP::transpose<ul>
<li>matrix tranpose, on a scalar it is a nop</li>
</ul>
</li>
<li>QDP::transposeColor<ul>
<li>matrix tranpose of color indices, on a scalar it is a nop</li>
</ul>
</li>
<li>QDP::transposeSpin<ul>
<li>matrix tranpose of spin indices, on a scalar it is a nop</li>
</ul>
</li>
<li>QDP::trace<ul>
<li>matrix trace</li>
</ul>
</li>
<li>QDP::traceColor<ul>
<li>matrix trace of color indices</li>
</ul>
</li>
<li>QDP::traceSpin<ul>
<li>matrix trace of spin indices</li>
</ul>
</li>
<li>QDP::real<ul>
<li>real part of complex</li>
</ul>
</li>
<li>QDP::imag<ul>
<li>imaginary part of complex</li>
</ul>
</li>
<li>QDP::timesI<ul>
<li>multiplies argument by imaginary <em>i</em> </li>
</ul>
</li>
<li>QDP::localNorm2<ul>
<li>on fibers, computes trace(adj(source)*source)</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="Binary"></a>
Binary</h3>
<ul>
<li>QDP::cmplx<ul>
<li>returns complex object arg1 + i*arg2</li>
</ul>
</li>
<li>QDP::localInnerProduct<ul>
<li>at each site computes trace(adj(arg1)*arg2)</li>
</ul>
</li>
<li>QDP::outerProduct<ul>
<li>at each site constructs (arg1<sub>i</sub> * arg2<sub>j</sub><sup>*</sup>)<sub>ij</sub></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="secinplace"></a>
In place functions</h2>
<ul>
<li>QDP::random<ul>
<li>uniform random numbers in all components</li>
</ul>
</li>
<li>QDP::gaussian<ul>
<li>Gaussian random numbers in all components</li>
</ul>
</li>
<li>QDP::copymask<ul>
<li>copy under a boolean mask</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="secbroadcasts"></a>
Broadcasts</h2>
<h3><a class="anchor" id="broadcastassign"></a>
Broadcasts via assignments</h3>
<p>i.e. via <code>operator=</code> </p>
<ul>
<li><em>LHS</em> = constant<ul>
<li>globally set conforming LHS to constant</li>
</ul>
</li>
<li><em>LHS</em> = zero<ul>
<li>globally set LHS to zero</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="secreductions"></a>
Global reductions</h2>
<ul>
<li>QDP::sum<ul>
<li>sum over lattice indices returning object of same fiber type</li>
</ul>
</li>
<li>QDP::norm2<ul>
<li>sum(localNorm2(arg1))</li>
</ul>
</li>
<li>QDP::innerProduct<ul>
<li>sum(localInnerProduct(arg1,arg2))</li>
</ul>
</li>
<li>QDP::sumMulti<ul>
<li>sum over each subset of Set returning #subset</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="secglobalcomparisons"></a>
Global comparisons</h2>
<ul>
<li>QDP::globalMax<ul>
<li>maximum over lattice indices (simple quantities)</li>
</ul>
</li>
<li>QDP::globalMin<ul>
<li>minimum over lattice indices (simple quantities)</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="secpeek"></a>
Accessors</h2>
<p>Peeking and poking (accessors) into various component indices of objects.</p>
<ul>
<li>QDP::peekSite (arg1,multi1d&lt;int&gt; coords)<ul>
<li>return object located at lattice coords</li>
</ul>
</li>
<li>QDP::peekColor (arg1,int row,int col)<ul>
<li>return color matrix elem row and col</li>
</ul>
</li>
<li>QDP::peekColor (arg1,int row)<ul>
<li>return color vector elem row</li>
</ul>
</li>
<li>QDP::peekSpin (arg1,int row,int col)<ul>
<li>return spin matrix elem row and col</li>
</ul>
</li>
<li>QDP::peekSpin (arg1,int row)<ul>
<li>return spin vector elem row</li>
</ul>
</li>
</ul>
<ul>
<li>QDP::pokeSite (dest,src,multi1d&lt;int&gt; coords)<ul>
<li>insert into site given by coords</li>
</ul>
</li>
<li>QDP::pokeColor (dest,src,int row,int col)<ul>
<li>insert into color matrix elem row and col</li>
</ul>
</li>
<li>QDP::pokeColor (dest,src,int row)<ul>
<li>insert into color vector elem row</li>
</ul>
</li>
<li>QDP::pokeSpin (dest,src,int row,int col)<ul>
<li>insert into spin matrix elem row and col</li>
</ul>
</li>
<li>QDP::pokeSpin (dest,src,int row)<ul>
<li>insert into spin vector elem row</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="secotherfuncs"></a>
More exotic functions</h2>
<ul>
<li>QDP::spinProject (QDPType psi, int dir, int isign)<ul>
<li>Applies spin projection (1 + isign* <img class="formulaInl" alt="$\gamma_\mu$" src="form_7.png"/>)*psi returning a half spin vector or matrix</li>
</ul>
</li>
</ul>
<ul>
<li>QDP::spinReconstruct (QDPType psi, int dir, int isign)<ul>
<li>Applies spin reconstruction of (1 + isign* <img class="formulaInl" alt="$\gamma_\mu$" src="form_7.png"/>)*psi returning a full spin vector or matrix</li>
</ul>
</li>
</ul>
<ul>
<li>QDP::quarkContract13 (a,b)<ul>
<li>Epsilon contract 2 quark propagators and return a quark propagator. This is used for diquark constructions. Eventually, it could handle larger QDP::Nc. The numbers represent which spin index to sum over.</li>
<li>The sources and targets must all be propagators but not necessarily of the same lattice type. Effectively, one can use this to construct an anti-quark from a di-quark contraction. In explicit index form, the operation quarkContract13 does <p class="formulaDsp">
<img class="formulaDsp" alt="\[\mathrm{target}^{k' k}_{\alpha\beta} = \epsilon^{i j k}\epsilon^{i' j' k'}* \mbox{source1}^{i i'}_{\rho\alpha}* \mbox{source2}^{j j'}_{\rho\beta}\]" src="form_8.png"/>
</p>
 and is (currently) only appropriate for QPD::Nc=3 (i.e. SU(3)).</li>
</ul>
</li>
</ul>
<ul>
<li><p class="startli">QDP::quarkContract14 (a,b)</p>
<ul>
<li>Epsilon contract 2 quark propagators and return a quark propagator:</li>
</ul>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\mbox{target}^{k' k}_{\alpha\beta} = \epsilon^{i j k}\epsilon^{i' j' k'}*\mbox{source1}^{i i'}_{\rho\alpha}*\mbox{source2}^{j j'}_{\beta\rho}\]" src="form_9.png"/>
</p>
</li>
</ul>
<ul>
<li>QDP::quarkContract23 (a,b)<ul>
<li>Epsilon contract 2 quark propagators and return a quark propagator. <p class="formulaDsp">
<img class="formulaDsp" alt="\[\mbox{target}^{k' k}_{\alpha\beta} = \epsilon^{i j k}\epsilon^{i' j' k'}*\mbox{source1}^{i i'}_{\alpha\rho}*\mbox{source2}^{j j'}_{\rho\beta}\]" src="form_10.png"/>
</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>QDP::quarkContract24 (a,b)<ul>
<li>Epsilon contract 2 quark propagators and return a quark propagator. <p class="formulaDsp">
<img class="formulaDsp" alt="\[\mbox{target}^{k' k}_{\alpha\beta} = \epsilon^{i j k}\epsilon^{i' j' k'}*\mbox{source1}^{i i'}_{\rho\alpha}*\mbox{source2}^{j j'}_{\beta\rho}\]" src="form_9.png"/>
</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>QDP::quarkContract12 (a,b) Epsilon contract 2 quark propagators and return a quark propagator. <p class="formulaDsp">
<img class="formulaDsp" alt="\[\mbox{target}^{k' k}_{\alpha\beta} = \epsilon^{i j k}\epsilon^{i' j' k'}*\mbox{source1}^{i i'}_{\rho\rho}*\mbox{source2}^{j j'}_{\alpha\beta}\]" src="form_11.png"/>
</p>
</li>
</ul>
<ul>
<li>QDP::quarkContract34 (a,b)<ul>
<li>Epsilon contract 2 quark propagators and return a quark propagator. <p class="formulaDsp">
<img class="formulaDsp" alt="\[\mbox{target}^{k' k}_{\alpha\beta} = \epsilon^{i j k}\epsilon^{i' j' k'}*\mbox{source1}^{i i'}_{\alpha\beta}*\mbox{source2}^{j j'}_{\rho\rho}\]" src="form_12.png"/>
</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>QDP::colorContract (a,b,c)<ul>
<li>Epsilon contract 3 color primitives and return a primitive scalar.</li>
<li>The sources and targets must all be of the same primitive type (a matrix or vector) but not necessarily of the same lattice type. In explicit index form, the operation colorContract does <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{target} = \epsilon^{i j k}\epsilon^{i' j' k'}* \mbox{source1}^{i i'}* \mbox{source2}^{j j'}*\mbox{source3}^{k k'} \]" src="form_13.png"/>
</p>
</li>
<li>or <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{target} = \epsilon^{i j k}* \mbox{source1}^{i}* \mbox{source2}^{j}*\mbox{source3}^{k} \]" src="form_14.png"/>
</p>
 and is (currently) only appropriate for Nc=3 (or SU(3)).</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="subtypeops"></a>
Operations on subtypes</h2>
<h3><a class="anchor" id="Subtypes"></a>
Subtypes</h3>
<p>Types in the QDP interface are parameterized by a variety of types, and can look like the following:</p>
<pre class="fragment">typedef OLattice&lt;PScalar&lt;PColorMatrix&lt;RComplex&lt;float&gt;, Nc&gt; &gt; &gt; LatticeColorMatrix
typedef OLattice&lt;PSpinVector&lt;PColorVector&lt;RComplex&lt;float&gt;, Nc&gt;, Ns&gt; &gt; LatticeFermion
</pre><dl class="section user"><dt>machinetype Word type </dt><dd>Basic machine types<ul>
<li>int</li>
<li>float</li>
<li>double</li>
<li>bool </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Reality type </dt><dd><ul>
<li>RComplex</li>
<li>RScalar </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Primitive type </dt><dd><ul>
<li>PScalar</li>
<li>PVector</li>
<li>PMatrix</li>
<li>PSeed </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Inner grid type </dt><dd><ul>
<li>IScalar</li>
<li>ILattice. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Outer grid type</dt><dd><ul>
<li>OScalar</li>
<li>OLattice.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="Operations"></a>
Operations</h3>
<p>Supported operations for each type level are as follows:</p>
<dl class="section user"><dt>Grid type</dt><dd><ul>
<li>OScalar</li>
<li>OLattice</li>
<li>IScalar</li>
<li>ILattice</li>
</ul>
</dd></dl>
<p>All operations listed in Sections <a class="el" href="impldetail.html#secinfix">Infix operators</a> - <a class="el" href="impldetail.html#secotherfuncs">More exotic functions</a></p>
<dl class="section user"><dt>Primitive type</dt><dd></dd></dl>
<dl class="section user"><dt>PScalar</dt><dd>All operations listed in Sections <a class="el" href="impldetail.html#secinfix">Infix operators</a> - <a class="el" href="impldetail.html#secotherfuncs">More exotic functions</a></dd></dl>
<dl class="section user"><dt>PMatrix</dt><dd><ul>
<li>Unary<ul>
<li>-(PMatrix)</li>
<li>+(PMatrix)</li>
</ul>
</li>
<li>Binary -(PMatrix,PMatrix)<ul>
<li>+(PMatrix,PMatrix)</li>
<li>*(PMatrix,PScalar)</li>
<li>*(PScalar,PMatrix)</li>
<li>*(PMatrix,PMatrix)</li>
</ul>
</li>
<li>Comparisons<ul>
<li>none</li>
</ul>
</li>
<li>Assignments<ul>
<li>=(PMatrix)</li>
<li>=(PScalar)</li>
<li>-=(PMatrix)</li>
<li>+=(PMatrix)</li>
<li>*=(PScalar)</li>
</ul>
</li>
<li>Ternary<ul>
<li>QDP::where</li>
</ul>
</li>
<li>C-lib funcs<ul>
<li>none</li>
</ul>
</li>
<li>QDP funcs<ul>
<li>all</li>
</ul>
</li>
<li>In place funcs<ul>
<li>all</li>
</ul>
</li>
<li>Reductions<ul>
<li>all</li>
</ul>
</li>
<li>Global Comparisons<ul>
<li>none</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>PVector</dt><dd></dd></dl>
<ul>
<li>Unary - -(PVector)<ul>
<li>+(PVector)</li>
</ul>
</li>
<li>Binary<ul>
<li>-(PVector,PVector)</li>
<li>+(PVector,PVector)</li>
<li>*(PVector,PScalar)</li>
<li>*(PScalar,PVector)</li>
<li>*(PMatrix,PVector)</li>
</ul>
</li>
<li>Comparisons<ul>
<li>none</li>
</ul>
</li>
<li>Assignments<ul>
<li>=(PVector)</li>
<li>-=(PVector)</li>
<li>+=(PVector)</li>
<li>*=(PScalar)</li>
</ul>
</li>
<li>Ternary<ul>
<li>QDP::where</li>
</ul>
</li>
<li>C-lib funcs<ul>
<li>none</li>
</ul>
</li>
<li>QDP funcs<ul>
<li>QDP::real</li>
<li>QDP::imag</li>
<li>QDP::timesI</li>
<li>QDP::localNorm2</li>
<li>QDP::cmplx</li>
<li>QDP::localInnerProduct</li>
<li>QDP::outerProduct</li>
</ul>
</li>
<li>In place funcs - all</li>
<li>Broadcasts<ul>
<li>=(Zero)</li>
</ul>
</li>
<li>Reductions<ul>
<li>all</li>
</ul>
</li>
<li>Global Comparisons<ul>
<li>none</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>PSpinMatrix</dt><dd></dd></dl>
<ul>
<li>Binary<ul>
<li>*(PSpinMatrix,QDP::Gamma)</li>
<li>*(QDP::Gamma,PSpinMatrix)</li>
</ul>
</li>
<li>Exotic<ul>
<li>QDP::peekSpin</li>
<li>QDP::pokeSpin</li>
<li>spinProjection</li>
<li>spinReconstruction</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>PSpinVector</dt><dd></dd></dl>
<ul>
<li>Binary<ul>
<li>*(QDP::Gamma,PSpinVector)</li>
</ul>
</li>
<li>Exotic<ul>
<li>QDP::peekSpin</li>
<li>QDP::pokeSpin</li>
<li>spinProjection</li>
<li>spinReconstruction</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>PColorMatrix</dt><dd></dd></dl>
<ul>
<li>Binary<ul>
<li>*(PColorMatrix,QDP::Gamma)</li>
<li>*(QDP::Gamma,PColorMatrix)</li>
</ul>
</li>
<li>Exotic<ul>
<li>QDP::peekColor</li>
<li>QDP::pokeColor</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>PColorVector</dt><dd></dd></dl>
<ul>
<li>Binary<ul>
<li>*(QDP::Gamma,PColorVector)</li>
</ul>
</li>
<li>Exotic<ul>
<li>QDP::peekColor</li>
<li>QDP::pokeColor</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Reality</dt><dd><ul>
<li>RScalar</li>
<li>RComplex</li>
</ul>
All operations listed in Sections <a class="el" href="impldetail.html#secinfix">Infix operators</a> - <a class="el" href="impldetail.html#secotherfuncs">More exotic functions</a>.</dd></dl>
<dl class="section user"><dt>Word</dt><dd><ul>
<li>int</li>
<li>float</li>
<li>double</li>
<li>bool</li>
</ul>
All operations listed in Sections <a class="el" href="impldetail.html#secinfix">Infix operators</a> - <a class="el" href="impldetail.html#secotherfuncs">More exotic functions</a>. Only boolean operations allowed on bool.</dd></dl>
<h1><a class="anchor" id="secdetails"></a>
Detailed function description</h1>
<p>The purpose of this section is to show some explicit prototypes and usages for the functions described in Section <a class="el" href="impldetail.html#secsupported">Supported Operations</a>. In that section, all the functions are shown with complete information on which operations and their meaning are supported on some combination of types. The purpose of this section is something like the inverse - namely show all the functions and what are some (selected) usages.</p>
<h2><a class="anchor" id="unaryops"></a>
Unary Operations</h2>
<dl class="section user"><dt>Elementary unary functions on reals</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type func(const Type&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = func(a) </em></li>
</ul>
</li>
<li>func<ul>
<li>QDP::cos</li>
<li>QDP::sin</li>
<li>QDP::tan</li>
<li>QDP::acos</li>
<li>QDP::asin</li>
<li>QDP::atan</li>
<li>QDP::sqrt</li>
<li>QDP::abs</li>
<li>QDP::exp</li>
<li>QDP::log</li>
<li>QDP::sign</li>
</ul>
</li>
<li>Type<ul>
<li>QDP::Real</li>
<li>QDP::LatticeReal</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Elementary unary functions on complex values</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type func(const Type&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = func(a) </em></li>
</ul>
</li>
<li>func<ul>
<li>QDP::exp</li>
<li>QDP::sqrt</li>
<li>QDP::log</li>
</ul>
</li>
<li>Type<ul>
<li>QDP::Complex</li>
<li>QDP::LatticeComplex</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Assignment operations</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type operator=(const Type&amp; r, const Type&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a</em></li>
</ul>
</li>
<li>Type<ul>
<li>All numeric types</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Shifting</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type QDP::shift (const Type&amp; a, int sign, int dir)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a</em></li>
</ul>
</li>
<li>Type<ul>
<li>All numeric types</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Hermitian conjugate</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type QDP::adj (const Type a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a<sup>dagger</sup></em></li>
</ul>
</li>
<li>Type<ul>
<li>QDP::Real</li>
<li>QDP::Complex</li>
<li>QDP::ColorMatrix</li>
<li>QDP::DiracPropagatorF, QDP::DiracPropagatorD <em>etc</em>.</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Transpose</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type QDP::transpose (const Type a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = transpose(a)</em></li>
</ul>
</li>
<li>Type<ul>
<li>QDP::Real</li>
<li>QDP::Complex</li>
<li>QDP::ColorMatrix</li>
<li>QDP::DiracPropagatorF, QDP::DiracPropagatorD <em>etc</em>.</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Transpose of color indices</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type QDP::transposeColor (const Type a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = transposeColor(a)</em></li>
</ul>
</li>
<li>Type<ul>
<li>QDP::Real</li>
<li>QDP::Complex</li>
<li>QDP::ColorMatrix</li>
<li>QDP::DiracPropagatorF, QDP::DiracPropagatorD <em>etc</em>.</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Transpose of spin indices</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type QDP::transposeSpin (const Type a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = transposeSpin(a)</em></li>
</ul>
</li>
<li>Type<ul>
<li>QDP::Real</li>
<li>QDP::Complex</li>
<li>QDP::SpinMatrix</li>
<li>QDP::DiracPropagatorF, QDP::DiracPropagatorD <em>etc</em>.</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Complex conjugate</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type QDP::conj (const Type a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r =a<sup>*</sup></em></li>
</ul>
</li>
<li>Type<ul>
<li>QDP::Real</li>
<li>QDP::Complex</li>
<li>QDP::ColorMatrix</li>
<li>QDP::DiracPropagatorF, QDP::DiracPropagatorD <em>etc</em>.</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="typeconv"></a>
Type conversion</h2>
<dl class="section user"><dt>Convert integer or float to double</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type2 Type2(const Type1&amp; a)</li>
</ul>
</li>
<li>Type1<ul>
<li>All single precision numeric types</li>
</ul>
</li>
<li>Type2<ul>
<li>All conforming double precision numeric types</li>
</ul>
</li>
<li>Example<ul>
<li>QDP::LatticeReal a; QDP::LatticeRealD r = QDP::LatticeRealD (a)</li>
<li>QDP::LatticeColorMatrix a; QDP::LatticeColorMatrixD r = QDP::LatticeColorMatrixD (a);</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Convert double to float</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type2 Type2(const Type1 a)</li>
</ul>
</li>
<li>Type1<ul>
<li>All double precision numeric types</li>
</ul>
</li>
<li>Type2<ul>
<li>All conforming single precision numeric types</li>
</ul>
</li>
<li>Example<ul>
<li>QDP::LatticeRealD a; QDP::LatticeReal r = QDP::LatticeReal (a)</li>
<li>QDP::LatticeColorMatrixD a; QDP::LatticeColorMatrix r = QDP::LatticeColorMatrix (a);</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Integer to real</dt><dd></dd></dl>
<ul>
<li>Syntax Type2 Type2(<code>const</code> Type1&amp; a)</li>
<li>Type1<ul>
<li>All integer precision numeric types</li>
</ul>
</li>
<li>Type2<ul>
<li>All conforming real precision numeric types</li>
</ul>
</li>
<li>Example<ul>
<li>QDP::LatticeInt a; QDP::LatticeReal r = QDP::LatticeReal (a);</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Real to integer</dt><dd></dd></dl>
<ul>
<li>Syntax Type2 Type2(const Type1&amp; a)</li>
<li>Example<ul>
<li>QDP::LatticeReal a; QDP::LatticeInt r = QDP::LatticeInt (a);</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Real to float</dt><dd></dd></dl>
<p>The QDP type QDP::Real is not a primitive type, so an explicit conversion is provided.</p>
<ul>
<li>Syntax<ul>
<li>float QDP::toFloat (const QDP::Real&amp; a)</li>
</ul>
</li>
<li>Meaning <em>r = float(a)</em></li>
<li>Example<ul>
<li>QDP::Real a; float r = QDP::toFloat (a);</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Double to double</dt><dd></dd></dl>
<p>The QDP type QDP::RealD is not a primitive type, so an explicit conversion is provided.</p>
<ul>
<li>Syntax<ul>
<li>double QDP::toDouble (const QDP::RealD&amp; a)</li>
</ul>
</li>
<li>Meaning <em>r = double(a)</em></li>
<li>Example<ul>
<li>QDP::RealD a; double r = QDP::toDouble (a);</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Boolean to bool</dt><dd></dd></dl>
<p>The QDP type QDP::Boolean is not a primitive type, so an explicit conversion is provided.</p>
<ul>
<li>Syntax<ul>
<li>bool QDP::toBool (const QDP::Boolean&amp; a)</li>
</ul>
</li>
<li>Meaning <em>r = bool(a)</em></li>
<li>Example<ul>
<li>QDP::Boolean a; bool r = QDP::toBool (a);</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="complexops"></a>
Operations on complex arguments</h2>
<dl class="section user"><dt>Convert real and imaginary to complex</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type QDP::cmplx (const Type1&amp; a, const Type2&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>Re r = a, Im r = b</em></li>
</ul>
</li>
<li>Type1<ul>
<li>Constant</li>
<li>QDP::Real</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
<li>Type2<ul>
<li>Constant</li>
<li>QDP::Real</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
<li>Type<ul>
<li>QDP::Complex</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Real part of complex</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type QDP::real (const Type&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = Re a</em></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Imaginary part of complex</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type QDP::imag (const Type&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = Im a</em></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="compextrins"></a>
Component extraction and insertion</h2>
<dl class="section user"><dt>Accessing a site object</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type QDP::peekSite (const LatticeType&amp; a, const multi1d&lt;int&gt;&amp; c)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a[x]</em></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Accessing a color matrix element</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>QDP::LatticeComplex QDP::peekColor (const QDP::LatticeColorMatrix&amp; a, int i, int j)</li>
<li>QDP::LatticeSpinMatrix QDP::peekColor (const QDP::LatticeDiracPropagator&amp; a, int i, int j)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a<sub>i,j</sub></em></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Inserting a color matrix element</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>QDP::LatticeColorMatrix&amp; QDP::pokeColor (QDP::LatticeColorMatrix&amp; r, const QDP::LatticeComplex&amp; a, int i, int j)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r<sub>i,j</sub> = a</em></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Accessing a color vector element</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>QDP::LatticeComplex QDP::peekColor (const QDP::LatticeColorVector&amp; a, int i)</li>
<li>QDP::LatticeSpinVector QDP::peekColor (const QDP::LatticeDiracFermion&amp; a, int i)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a<sub>i</sub></em></li>
</ul>
</li>
</ul>
<p>This function will extract the desired color component with all the other indices unchanged.</p>
<p>A lattice color vector is another name (typedef) for a QDP::LatticeStaggeredFermion. Namely, an object that is vector in color spin and a scalar in spin space. Together with spin accessors, one can build a QPD::LatticeDiracFermion.</p>
<dl class="section user"><dt>Inserting a color vector element </dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>QDP::LatticeColorVector QDP::pokeColor (QDP::LatticeColorVector&amp; r, const QDP::LatticeComplex&amp; a, int i})</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r<sub>i</sub> = a</em></li>
</ul>
</li>
</ul>
<p>This function will extract the desired color component with all the other indices unchanged.</p>
<p>A lattice color vector is another name (typedef) for a QDP::LatticeStaggeredFermion. Namely, an object that is vector in color spin and a scalar in spin space. Together with spin accessors, one can build a QDP::LatticeDiracFermion{} or a QDP::LatticeDiracPropagator.</p>
<dl class="section user"><dt>Accessing a spin matrix element</dt><dd><ul>
<li>Syntax<ul>
<li>QDP::LatticeComplex QDP::peekSpin (const QDP::LatticeSpinMatrix&amp; a, int i, int j)</li>
<li>QDP::LatticeColorMatrix QDP::peekSpin (const QDP::LatticeDiracPropagator&amp; a, int i, int j)\</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a<sub>i,j</sub></em></li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Inserting a spin matrix element</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>QDP::LatticeSpinMatrix&amp; QDP::pokeSpin (QDP::LatticeSpinMatrix&amp; r, const QDP::LatticeComplex&amp; a, int i, int j)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r<sub>i,j</sub> = a</em></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Accessing a spin vector element</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>QDP::LatticeComplex QDP::peekSpin (const QDP::LatticeSpinVector&amp; a, int i)</li>
<li>QDP::LatticeColorVector QDP::peekSpin (const QDP::LatticeDiracFermion&amp; a, int i)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a<sub>i</sub></em></li>
</ul>
</li>
</ul>
<p>This function will extract the desired spin component with all the other indices unchanged.</p>
<p>A lattice spin vector is an object that is a vector in spin space and a scalar in color space. Together with color accessors, one can build a QDP::LatticeDiracFermion or a QDP::LatticeDiracPropagator.</p>
<dl class="section user"><dt>Inserting a spin vector element</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>QDP::LatticeSpinVector QDP::pokeSpin (QDP::LatticeSpinVector&amp; r, const QDP::LatticeComplex&amp; a, int i)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r<sub>i</sub> = a</em></li>
</ul>
</li>
</ul>
<p>This function will extract the desired spin component with all the other indices unchanged.</p>
<p>A lattice spin vector is an object that is a vector in spin space and a scalar in color space. Together with color accessors, one can build a QDP::LatticeDiracFermion or a QDP::LatticeDiracPropagator.</p>
<dl class="section user"><dt>Trace of matrix</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type2 QDP::trace (const Type1&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = Tr a</em></li>
</ul>
</li>
<li>Type1<ul>
<li>QDP::ColorMatrix</li>
<li>QDP::DiracPropagatorD, QDP::DiracPropagatorF, <em>etc</em>.</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
<li>Type2<ul>
<li>QDP::Complex</li>
<li>QDP::Complex</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
<li>Example QDP::LatticeColorMatrix a; QDP::LatticeComplex r = QDP::trace (a);</li>
</ul>
<p>Traces over all matrix indices. It is an error to trace over a vector index. It will trivially trace a scalar variable.</p>
<dl class="section user"><dt>Color trace of matrix</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type2 QDP::traceColor (const Type1&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em> r = Tr a</em></li>
</ul>
</li>
<li>Type1<ul>
<li>QDP::ColorMatrix</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
<li>Type2<ul>
<li>QDP::Complex</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
<li>Example<ul>
<li>QDP::LatticeDiracPropagator a;</li>
<li>QDP::LatticeSpinMatrix r = QDP::traceColor (a);</li>
</ul>
</li>
</ul>
<p>Traces only over color matrix indices. It is an error to trace over a color vector index. All other indices are left untouched. It will trivially trace a scalar variable.</p>
<dl class="section user"><dt>Spin trace of matrix</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type2 QDP::traceSpin (const Type1&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em> r = Tr a</em></li>
</ul>
</li>
<li>Type1<ul>
<li>QDP::DiracPropagatorF, QDP::DiracPropagatorD, <em>etc</em>.</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
<li>Type2<ul>
<li>QDP::ColorMatrix</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
<li>Example<ul>
<li>QDP::LatticeDiracPropagator a;</li>
<li>QDP::LatticeColorMatrix r = QDP::traceSpin(a);</li>
</ul>
</li>
</ul>
<p>Traces only over spin matrix indices. It is an error to trace over a spin vector index. All other indices are left untouched. It will trivially trace a scalar variable.</p>
<dl class="section user"><dt>Dirac spin projection</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type2 QDP::spinProject (const Type1&amp; a, int d, int p)</li>
</ul>
</li>
<li>Meaning<ul>
<li><img class="formulaInl" alt="$r = (1 + p\gamma_d)a$" src="form_15.png"/></li>
</ul>
</li>
<li>Type1<ul>
<li>QDP::DiracFermionF, QDP::DiracFermionD <em>etc</em>.</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
<li>Type2<ul>
<li>QDP::HalfFermion</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Dirac spin reconstruction</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type2 QDP::spinReconstruct (const Type1&amp; a, int d, int p)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = recon(p,d,a)</em></li>
</ul>
</li>
<li>Type1<ul>
<li>QDP::HalfFermion</li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
<li>Type2<ul>
<li>QDP::DiracFermionF, QDP::DiracFermionD, <em>etc</em> </li>
<li>Also corresponding lattice variants</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="binopconst"></a>
Binary Operations with Constants</h2>
<dl class="section user"><dt>Multiplication by real constant</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type operator*(const QDP::Real&amp; a, const Type&amp; b)</li>
<li>Type operator*(const Type&amp; b, const QDP::Real&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a*b</em> (<em>a</em> real, constant)</li>
</ul>
</li>
<li>Type<ul>
<li>All floating types</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Multiplication by complex constant</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type operator*(const QDP::Real&amp; a, const Type&amp; b)\</li>
<li>Type operator*( const Type&amp; b, const QDP::Real &amp;a)\</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a*b</em> (<em>a</em> complex, constant)</li>
</ul>
</li>
<li>Type<ul>
<li>All numeric types</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Left multiplication by gamma matrix</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type operator*(const QDP::Gamma&amp; a, const Type&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><img class="formulaInl" alt="$r = \gamma_d * a$" src="form_16.png"/></li>
</ul>
</li>
<li>Gamma<ul>
<li>Gamma constructed from an explicit integer in [0,N<sub>s</sub><sup>2</sup>-1]</li>
</ul>
</li>
<li>Types<ul>
<li>QDP::SpinVector</li>
<li>QDP::SpinMatrix</li>
<li>QDP::HalfFermion</li>
<li>QDP::DiracFermionF, QDP::DiracFermionD <em>etc</em>.</li>
<li>QDP::DiracPropagatorF, QDP::DiracPropagatorD <em>etc</em>.</li>
<li>similar lattice variants</li>
</ul>
</li>
<li>Example<ul>
<li>r = QDP::Gamma (7) * b;</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Right multiplication by gamma matrix</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type operator*(const Type&amp; a, const Gamma&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><img class="formulaInl" alt="$r = a * \gamma_d$" src="form_17.png"/></li>
</ul>
</li>
<li>Gamma<ul>
<li>Gamma constructed from an explicit integer in [0,N<sub>s</sub><sup>2</sup>-1]</li>
</ul>
</li>
<li>Types<ul>
<li>QDP::SpinVector</li>
<li>QDP::SpinMatrix</li>
<li>QDP::HalfFermion</li>
<li>QDP::DiracFermionF, QDP::DiracFermionD <em>etc</em>.</li>
<li>QDP::DiracPropagatorF, QDP::DiracPropagatorD <em>etc</em>.</li>
<li>similar lattice variants</li>
</ul>
</li>
</ul>
<p>See Section <a class="el" href="spinpage.html#secspin">Spin Conventions</a> for details on <img class="formulaInl" alt="$\gamma$" src="form_3.png"/>-matrix conventions.</p>
<h2><a class="anchor" id="binopfield"></a>
Binary Operations with Fields</h2>
<dl class="section user"><dt>Division of real fields</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type operator/(const Type&amp; a, const Type&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a / b</em></li>
</ul>
</li>
<li>Type<ul>
<li>All numeric types</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Addition</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type operator+(const Type&amp; a, const Type&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a + b</em></li>
</ul>
</li>
<li>Type<ul>
<li>All numeric types</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Subtraction</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type operator-(const Type&amp; a, const Type&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a - b</em></li>
</ul>
</li>
<li>Type<ul>
<li>All numeric types</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Multiplication: uniform types</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type operator*(const Type&amp; a, const Type&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a * b</em></li>
</ul>
</li>
<li>Type<ul>
<li>Constant</li>
<li>QDP::Real</li>
<li>QDP::Complex</li>
<li>QDP::Int</li>
<li>QDP::ColorMatrix</li>
<li>QDP::SpinMatrix</li>
<li>QDP::DiracPropagatorF, QDP::DiracPropagatorD, <em>etc</em>.</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>ColorMatrix matrix from outer product</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type QDP::outerProduct (const Type1&amp; a, const Type2&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r<sub>j,k</sub> = a<sub>j</sub> * b<sub>k</sub><sup>*</sup></em></li>
</ul>
</li>
<li>Type1<ul>
<li>QDP::ColorVector</li>
<li>QDP::LatticeColorVector</li>
</ul>
</li>
<li>Type2<ul>
<li>QDP::ColorVector</li>
<li>QDP::LatticeColorVector</li>
</ul>
</li>
<li>Type<ul>
<li>QDP::ColorMatrix</li>
<li>QDP::LatticeColorMatrix</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Left multiplication by gauge matrix</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type operator*(const Type1&amp; a, const Type&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a * b </em></li>
</ul>
</li>
<li>Type1<ul>
<li>QDP::ColorMatrix</li>
<li>QDP::LatticeColorMatrix</li>
</ul>
</li>
<li>Type<ul>
<li>Constant</li>
<li>QDP::Complex</li>
<li>QDP::ColorMatrix</li>
<li>QDP::ColorVector</li>
<li>QDP::SpinVector</li>
<li>QDP::DiracPropagatorF, QDP::DiracPropagatorD, <em>etc</em>.</li>
<li>and similar lattice variants</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Right multiplication by gauge matrix</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type operator*(const Type&amp; a, const Type1&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a * b </em></li>
</ul>
</li>
<li>Type1<ul>
<li>QDP::ColorMatrix</li>
<li>QDP::LatticeColorMatrix</li>
</ul>
</li>
<li>Type<ul>
<li>QDP::ColorMatrix</li>
<li>QDP::SpinMatrix</li>
<li>QDP::DiracPropagatorF, QDP::DiracPropagatorD, <em>etc</em>.</li>
<li>and similar lattice variants</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="boolbit"></a>
Boolean and Bit Operations</h2>
<dl class="section user"><dt>Comparisons</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type2 op(const Type&amp; a, const Type1&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a op b</em></li>
<li><em>r = op(a, b)</em></li>
</ul>
</li>
<li>op<ul>
<li>&lt;</li>
<li>&gt;</li>
<li>!=</li>
<li>&lt;=</li>
<li>&gt;=</li>
<li>==</li>
</ul>
</li>
<li>Type1<ul>
<li>QDP::Int</li>
<li>QDP::Real</li>
<li>QDP::RealD</li>
<li>similar lattice variants</li>
</ul>
</li>
<li>Type2<ul>
<li>QDP::Boolean</li>
<li>QDP::LatticeBoolean (result is lattice if any arg is lattice)</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Elementary binary operations on integers</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type2 op(const Type&amp; a, const Type1&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a op b</em></li>
<li><em>r = op(a, b)</em></li>
</ul>
</li>
<li>op<ul>
<li>&lt;&lt;</li>
<li>&gt;&gt;</li>
<li>&amp;</li>
<li>|</li>
<li>^</li>
<li>mod</li>
<li>max</li>
<li>min</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Elementary binary operations on reals</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type2 op(const Type&amp; a, const Type1&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a op b</em></li>
<li><em>r = op(a, b)</em></li>
</ul>
</li>
<li>op<ul>
<li>mod</li>
<li>max</li>
<li>min</li>
</ul>
</li>
<li>Type<ul>
<li>QDP::Real</li>
<li>QDP::RealD</li>
<li>similar lattice variants</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Boolean Operations</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type op(const Type&amp; a, const Type&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = a op b</em></li>
</ul>
</li>
<li>op<ul>
<li>|</li>
<li>&amp;</li>
<li>^</li>
</ul>
</li>
<li>Type<ul>
<li>QDP::Boolean</li>
<li>QDP::LatticeBoolean</li>
</ul>
</li>
</ul>
<ul>
<li>Syntax -Type op(const Type&amp; a)</li>
<li>Meaning<ul>
<li><em>r = not a</em></li>
</ul>
</li>
<li>op<ul>
<li>!</li>
</ul>
</li>
<li>Type<ul>
<li>QDP::Boolean</li>
<li>QDP::LatticeBoolean</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Copymask</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>void QDP::copymask (const Type2&amp; r, const Type1&amp; a, const Type1&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = b</em> if <em>a</em> is true</li>
</ul>
</li>
<li>Type<ul>
<li>All numeric types</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="reductions"></a>
Reductions</h2>
<p>Global reductions sum over all lattice sites in the subset specified by the left hand side of the assignment.</p>
<dl class="section user"><dt>Norms</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>QDP::Real QDP::norm2 (Type&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><img class="formulaInl" alt="$r = \sum |a|^2$" src="form_18.png"/></li>
</ul>
</li>
<li>Type<ul>
<li>All numeric types</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Inner products</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>QDP::Complex QDP::innerProduct (Type&amp; a, const Type&amp; b)</li>
</ul>
</li>
<li>Meaning<ul>
<li><img class="formulaInl" alt="$r = \sum a^\dagger \cdot b$" src="form_19.png"/></li>
</ul>
</li>
<li>Type<ul>
<li>All numeric types</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Global sums</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type QDP::sum (const LatticeType&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><img class="formulaInl" alt="$r = \sum a$" src="form_20.png"/></li>
</ul>
</li>
<li>Type<ul>
<li>All numeric types</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="globalcomparisons"></a>
Global comparisons</h2>
<p>Find the maximum or minimum of a quantity across the lattice. These operations do not have subset variants.</p>
<dl class="section user"><dt>Global maximum</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type QDP::globalMax (const LatticeType&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><img class="formulaInl" alt="$r = max_x a(x)$" src="form_21.png"/></li>
</ul>
</li>
<li>Type<ul>
<li>Only reals</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Global minimum</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type QDP::globalMin (const LatticeType&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><img class="formulaInl" alt="$r = min_x a(x)$" src="form_22.png"/></li>
</ul>
</li>
<li>Type<ul>
<li>Only reals</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="fills"></a>
Fills</h2>
<dl class="section user"><dt>Coordinate function fills</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>QDP::LatticeInt Layout::latticeCoordinate( int d)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = f(d)</em> for direction <em>d</em> </li>
<li>Returns the lattice coordinates in direction <em>d</em> </li>
</ul>
</li>
</ul>
<p>The call Layout::latticeCoordinate (d) returns an integer lattice field with a value on each site equal to the integer value of the <em>d</em>th space-time coordinate on that site.</p>
<dl class="section user"><dt>Constant fills</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>LatticeType operator=(LatticeType&amp; r, const Type&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em> r = a </em> for all sites</li>
</ul>
</li>
<li>Types<ul>
<li>All non-lattice objects</li>
</ul>
</li>
<li>Example<ul>
<li>QDP::Real a = 2.0;</li>
<li>QDP::LatticeReal r = a;</li>
</ul>
</li>
</ul>
<p>Constant (or lattice global) fills are always defined for lattice scalar objects broadcasting to all lattice sites. These are broadcasts of a lattice scalar type to a conforming lattice type.</p>
<p>N.B. one cannot fill a QDP::LatticeColorVector with a QDP::Real.</p>
<ul>
<li>Syntax<ul>
<li>LatticeType operator=(LatticeType&amp; r, const Type&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = diag(a, a, ..., a)</em> (constant <em>a</em>)</li>
</ul>
</li>
<li>Type<ul>
<li>QDP::Complex</li>
<li>QDP::ColorMatrix</li>
<li>QDP::SpinMatrix</li>
</ul>
</li>
<li>Example<ul>
<li>QDP::Real a = 2.0;</li>
<li>QDP::LatticeColorMatrix r = a;</li>
</ul>
</li>
</ul>
<p>Only sets the diagonal part of a field to a constant <em>a</em> times the identity.</p>
<p>This fill can only be used on primitive types that are scalars or matrices. E.g., it can not be used for a vector field since there is no meaning of diagonal. N.B., a zero cannot be distinguished from a constant like 1. To initialize to zero the <em>zero</em> argument must be used.</p>
<dl class="section user"><dt>Zero fills</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>Type operator=(Type&amp; r, const Zero&amp; zero)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r = 0</em></li>
</ul>
</li>
<li>Type<ul>
<li>All numeric types</li>
</ul>
</li>
<li>Example<ul>
<li>QDP::LatticeDiracFermion r = zero;</li>
</ul>
</li>
</ul>
<p>This is the only way to fill a vector field with a constant (like zero).</p>
<dl class="section user"><dt>Uniform random number fills</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>void QDP::random (Type&amp; r)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r</em> random, uniform on [0,1]</li>
</ul>
</li>
<li>Type<ul>
<li>All floating types</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Gaussian random number fills</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>void QDP::random (Type&amp; r)</li>
</ul>
</li>
<li>Meaning<ul>
<li><em>r</em> random, normal gaussian</li>
</ul>
</li>
<li>Type<ul>
<li>All floating types</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Seeding the random number generator</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>void RNG::setrn (const QDP::RandomState&amp; a)</li>
</ul>
</li>
<li>Meaning<ul>
<li>Initialize the random number generator with seed state <em>a</em>.</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Extracting the random number generator seed</dt><dd></dd></dl>
<ul>
<li>Syntax<ul>
<li>void RNG::savern ( QDP::RandomState&amp; r)</li>
</ul>
</li>
<li>Meaning<ul>
<li>Extract the random number generator into seed state <em>r</em> </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 23 2014 15:12:06 for QDP++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
