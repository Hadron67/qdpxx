<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>QDP++</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<style type="text/css"> code{ font-size: 130% } </style>
</head>
<body>
<center>
<b>QDP++  User Guide: &nbsp;</b>
<a class="qindex" href="index.html">Front Page</a> &nbsp;
<a class="qindex" href="intropage.html">Introduction</a> &nbsp;
<a class="qindex" href="datatypespage.html">Data Types</a> &nbsp;
<a class="qindex" href="qdpfuncpage.html">Functions</a> &nbsp;
<a class="qindex" href="simpleiopage.html">Simple IO</a> &nbsp;
<a class="qindex" href="qiopage.html">Record IO</a>&nbsp; 
<a class="qindex" href="buildpage.html">Compilation</a> &nbsp; 
<a class="qindex" href="spinpage.html">Spin Conventions</a> &nbsp; 
<a class="qindex" href="impldetail.html">Implementation</a> 
</center>
<hr>
<!-- Generated by Doxygen 1.8.2 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">QDP Functions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="qdpfuncs"></a>
QDP Functions</h1>
<p>The QDP functions are grouped into the following categories:</p>
<ol type="1">
<li><a class="el" href="qdpfuncpage.html#secinit_qdp">Entry and exit from QDP</a></li>
<li><a class="el" href="qdpfuncpage.html#layout">Layout utilities</a></li>
<li><a class="el" href="qdpfuncpage.html#dataparfuncs">Data Parallel Functions</a></li>
<li><a class="el" href="qdpfuncpage.html#createdestroy">Creating and destroying lattice fields</a></li>
<li><a class="el" href="qdpfuncpage.html#secarrays">Array container objects</a></li>
<li><a class="el" href="qdpfuncpage.html#secfuncobj">Function objects</a></li>
<li><a class="el" href="qdpfuncpage.html#subsets">Subsets</a></li>
<li><a class="el" href="qdpfuncpage.html#secshifts">Maps and shifts</a></li>
<li><a class="el" href="qdpfuncpage.html#tempentryexit">Temporary entry and exit from QDP</a></li>
</ol>
<h2><a class="anchor" id="secinit_qdp"></a>
Entry and exit from QDP</h2>
<p>QDP must be initialized before any other routine can be used. The initialization is broken into two steps &ndash; initializing the underlying hardware and initializing the layout.</p>
<h3><a class="anchor" id="qdpinit"></a>
Initialization of QDP</h3>
<p>Call QDP::QDP_initialize(int *argc, char ***argv).</p>
<p>This routine will be responsible for initializing any hardware like the physical layer of the message passing system. For compatibility with QMP, the addresses of the main program's <em>argc</em> and <em>argv</em> arguments must be passed. They may be modified.</p>
<h3><a class="anchor" id="qdpshutdown"></a>
Shutdown of QDP</h3>
<p>Call QDP::QDP_finalize().</p>
<p>This routine provides for an orderly shutdown of QDP. It is called by all nodes. It concludes all communications, does housekeeping, if needed and performs a barrier wait for all nodes. Then it returns control to the calling process.</p>
<h3><a class="anchor" id="qdppanic"></a>
Panic exit from QDP</h3>
<p>Call QDP::QDP_abort(int status).</p>
<p>This routine may be called by one or more nodes. It sends kill signals to all nodes and exits with exit status <em>status</em>.</p>
<h3><a class="anchor" id="qdpinitlayout"></a>
Entry into QDP</h3>
<p>Call Layout::create().</p>
<p>This routine is called once by all nodes and starts QDP operations. It calls the layout routine with the parameters set in the namespace Layout specifying the layout. The layout is discussed in <a class="el" href="qdpfuncpage.html#layout">Layout utilities</a>.</p>
<p>This step is separated from the QDP::QDP_initialize() above so layout parameters can be read and broadcasted to the nodes. Otherwise the layout parameters have to be set from the environment or fixed in the compilation.</p>
<h3><a class="anchor" id="qdpexit"></a>
Exit from QDP</h3>
<p>Call Layout::destroy().</p>
<p>This call provides for an orderly exit from QDP. It is called by all nodes. It concludes all communications, does housekeeping, if needed and performs a barrier wait for all nodes. The communication layer is not finalized.</p>
<h2><a class="anchor" id="layout"></a>
Layout utilities</h2>
<p>Routines for constructing the layout are collected in the namespace Layout. The <em>set</em> and <em>get</em> routines provide a way to set parameters like the lattice size.</p>
<p>The layout creation function determines which nodes get which lattice sites and in what linear order the sites are stored. The Layout namespace has entry points that allow a user to inquire about the lattice layout to facilitate accessing single site data from a QDP lattice field. For code written entirely with other QDP calls, these routines may be ignored by the user, with the exception of the useful routine latticeCoordinate. However, if a user removes data from a QDP lattice object (see expose or extract) and wishes to manipulate the data on a site-by-site basis, the global entry points provided here are needed to locate the site data.</p>
<p>Some implementations may have a built-in tightly constrained layout. In flexible implementations there may be several layout choices, thereby allowing the user the freedom to select one that works best with a given application. Furthermore, such implementations may allow the user to create a custom layout to replace one of the standard layouts. As long as the custom layout procedure provides the entry points and functionality described here, compatibility with the remainder of the QDP library is assured.</p>
<h3><a class="anchor" id="qdpsetup"></a>
QDP setup</h3>
<dl class="section user"><dt>Layout creation</dt><dd></dd></dl>
<p>The layout creation routine Layout::create() described in <a class="el" href="qdpfuncpage.html#secinit_qdp">Entry and exit from QDP</a> generates predefined lattice subsets for specifying even, odd, and global subsets of the lattice. The QDP::rb set can be dereferenced to produce the QDP::even and QDP::odd subsets:</p>
<p>QDP::Subset QDP::even, QDP::odd, QDP::all, QDP::rb[0], QDP::rb[1], QDP::mcb[0], ...,QDP::mcb[1 &lt;&lt; (QDP::Nd+1)]</p>
<p>It also creates the nearest-neighbor shifts for each coordinate direction.</p>
<dl class="section user"><dt>Defining the layout</dt><dd></dd></dl>
<p>There are set/accessor functions to specify the lattice geometry used in the layout. Generically, the accessors have the form:</p>
<p>Layout::set<em>something</em>(<em>parameters</em>)</p>
<p>The type of input information needed by the layout is as follows:</p>
<ol type="1">
<li>Number of dimensions <em>N<sub>d</sub></em>. Must be the compile time dimensions.</li>
<li>Lattice size (e.g., <em>L<sub>0</sub></em>, <em>L<sub>1</sub></em>, ..., <em>L<sub>N<sub>d-1</sub></sub></em>)</li>
<li>SMP flag</li>
</ol>
<p>These parameters are accessed and set with the following functions:</p>
<ul>
<li>void Layout::setLattSize(const multi1d&lt;int&gt;&amp; size)<ul>
<li>Sets the lattice size for the data layout.</li>
<li>No default value. Must always be set</li>
</ul>
</li>
<li>void Layout::setSMPFlag(bool)<ul>
<li>Turns on using multi-processor/threading.</li>
<li>Default value is <em>false</em>, i.e. a single thread of execution.</li>
</ul>
</li>
<li>void Layout::setNumProc(int N)<ul>
<li>In a multi-threaded implementation, use <em>N</em> processors.</li>
<li>Default value is 1, i.e. a single thread of execution.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="genericlayout"></a>
Generic layout information</h3>
<p>The following global entry points are provided in the Layout namespace. They provide generic user information.</p>
<dl class="section user"><dt>Returning the spacetime coordinates</dt><dd></dd></dl>
<p>The call to Layout::latticeCoordinate(d) returns an integer lattice field of type QDP::LatticeInt with a value on each site equal to the integer value of the <em>d</em>th space-time coordinate on that site.</p>
<dl class="section user"><dt>Lattice volume</dt><dd></dd></dl>
<p>int Layout::vol() returns the total lattice volume.</p>
<h3><a class="anchor" id="layoutentry"></a>
Entry points specific to the layout</h3>
<p>The additional global entry points are provided in the Layout namespace. They reveal some information specific to the implementation.</p>
<dl class="section user"><dt>Node number of site</dt><dd></dd></dl>
<p>int QDP::Layout::nodeNumber(const multi1d&lt;int&gt;&amp; x) returns logical node number containing site <em>x</em>.</p>
<dl class="section user"><dt>Linear index of site</dt><dd></dd></dl>
<p>int Layout::linearSiteIndex(const multi1d&lt;int&gt;&amp; x) returns the linearized index for the lattice site <em>x</em> </p>
<dl class="section user"><dt>Map node and linear index to coordinate</dt><dd></dd></dl>
<p>multi1d&lt;int&gt; Layout::siteCoords(int node, int index) returns site coordinate <em>x</em> for the given node <em>node</em> and linear index <em>index</em>.</p>
<dl class="section user"><dt>Number of sites on a node</dt><dd></dd></dl>
<p>int Layout::sitesOnNode() returns number of sites assigned to a node.</p>
<p>The linear index returned by Layout::linearSiteIndex() ranges from 0 to Layout::sitesOnNode() - 1.</p>
<h2><a class="anchor" id="dataparfuncs"></a>
Data Parallel Functions</h2>
<p>Data parallel functions are described in detail in <a class="el" href="impldetail.html#secsupported">Supported Operations</a>. In the C++ API, there are overloaded functions that can be applied to site or lattice wide objects. Arbitrarily complicated expressions can be built from these functions. The design of the API describes that all operations are to be performed site-wise. The only connection between sites is via a map or shift function.</p>
<p>The class of operations are generically described by site-wise operations (the <em>linear algebra</em> part of the API), and shift (or map) versions. The latter generically involves communications among processors in a parallel implementation.</p>
<p>The operator style provided by the API thus allows operations like the following: </p>
<pre class="fragment">  LatticeFermion A, B;
  LatticeColorMatrix U;
  B = U * A;
</pre><p>From the type declarations </p>
<pre class="fragment">typedef OLattice&lt;PScalar&lt;PColorMatrix&lt;RComplex&lt;float&gt;, Nc&gt; &gt; &gt; LatticeColorMatrix
typedef OLattice&lt;PSpinVector&lt;PColorVector&lt;RComplex&lt;float&gt;, Nc&gt;, Ns&gt; &gt; LatticeFermion
</pre><p> (see QDP::LatticeColorMatrix and QDP::LatticeFermion <em>etc</em>. in defs)</p>
<p>one can see a OLattice multiplies a OLattice. At each site, the <em>U</em> field is a scalar in spin space, thus a Scalar multiplies a PSpinVector, a vector in spin space. For each spin component, there is a PColorMatrix multipling a PColorVector. The multiplications involve complex numbers.</p>
<p>Thus we see that mathematically the expression carries out the product </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\rm B}_\alpha^{i}(x) = {\rm U}^{i j}(x) * {\rm A}_\alpha^{j}(x) \]" src="form_1.png"/>
</p>
<p>for all lattice coordinates <em>x</em> belonging to the subset QDP::all. Here <em>A</em> and <em>B</em> are objects of lattice Dirac fermion fields and <em>U</em> is an onject of type lattice gauge field. The superscripts <em>i</em> and <em>j</em> refer to the color indices and the subscript <img class="formulaInl" alt="$\alpha$" src="form_2.png"/> refers to the spin index. For each spin and color component, the multiplication is over complex types.</p>
<p>This tensor product factorization of types allows for potentially a huge variety of mathematical objects. The operations between the objects is determined by their tensor product structure.</p>
<p>The API allows for operations to be narrowed to a subset of sites. The infix notation does not allow for extra arguments to be passed to an operation, so the subset is fixed via the target. The API mandates that there is in use in even a complex operation, namely the target specifies the subset to use. To narrow an operation to a specific subset, one specifies the subset in the target as follows:</p>
<pre class="fragment">  chi[even] = u * psi;
</pre><p>which will store the result of the multiplication on only the <em>even</em> subset QDP::even.</p>
<p>The C++ API differs from the C API signficantly in the name of functions. In C++ there is no need for naming conventions for the functions since one can overload the function name on the types of its arguments. More significantly, the C API uses a functional style where the destination of an operation is part of the arguments for an operation, and all functions return void. The C++ API uses an operator/infix style allowing complex expressions to be built.</p>
<h3><a class="anchor" id="constargs"></a>
Constant Arguments</h3>
<p>In some cases it is desirable to keep an argument constant over the entire subset. For example the function</p>
<pre class="fragment">   Complex z;
   LatticeFermion c, b;
   c[s] = z * b;
</pre><p>multiplies a lattice field of color vectors by a complex constant as in</p>
<pre class="fragment">   c[x] = z*b[x]
</pre><p>for <em>x</em> in subset <em>s</em>.</p>
<h3><a class="anchor" id="morefuncs"></a>
Functions</h3>
<p>In the C++ API all operations are functions that act on their argument and most functions return their results. Except for explicit shift functions and global reductions, these functions are point-wise. The C++ API differs from the C API in that there are no combined operations like adjoint with a multiply. Instead, one simply calls the adjoint function QDP::adj. Thus</p>
<pre class="fragment">  c = adj(u)*b
</pre><p>carries out the product</p>
<pre class="fragment">  c[x] = adj(u[x])*b[x]
</pre><p>for all sites <em>x</em> in subset QDP::all.</p>
<h3><a class="anchor" id="gammamatrices"></a>
Gamma matrices</h3>
<p>Multiplication of spin vectors and matrices by <img class="formulaInl" alt="$\gamma$" src="form_3.png"/>-matrices is provided by QDP::Gamma.</p>
<pre class="fragment">  LatticeDiracFermion c, b;
  int n;
  c = Gamma(n) * b;
</pre><p>where the multiplciation is spin matrix times a spin vector. Right multiplication is also supported.</p>
<pre class="fragment">  LatticePropagator q, r;
  int n;
  q = r * Gamma(n);
</pre><p>The QDP::Gamma provides an enumeration of all possible <img class="formulaInl" alt="$\gamma$" src="form_3.png"/>-matrix combinations. See the Section <a class="el" href="spinpage.html#secspin">Spin Conventions</a> for more details.</p>
<h3><a class="anchor" id="shifty"></a>
Shift</h3>
<p>A shift function is a type of map that maps sites from one lattice site to another. In general, maps can be permutation maps but there are nearest neighbor shift functions provided by default. They are implemented in QDP::shift. See the discussion of shifts below in Section <a class="el" href="qdpfuncpage.html#secshifts">Maps and shifts</a>. Thus</p>
<pre class="fragment">  c[s] = shift(b,sign,dir)
</pre><p>shifts an object along the direction specified by <em>dir</em> and <em>sign</em> for all sites <em>x</em> in destination subset <em>s</em>. Here <em>sign</em> = <img class="formulaInl" alt="$\pm 1$" src="form_4.png"/> and <em>dir</em> = 0, ..., QDP::Nd - 1.</p>
<h2><a class="anchor" id="createdestroy"></a>
Creating and destroying lattice fields</h2>
<p>The declaration of an object of some type say QDP::LatticeReal will call a constructor. The implementation guarantees the object is fully created and all memory needed for it is allocated. Thus, there is no need for the user to use <em>new</em> to create an object. The use of pointers is discouraged. When an object goes out of scope, a destructor is called which will guarantee all memory associated with the object is released.</p>
<p>There is no aliasing or referencing of two objects with the same internal data storage. Each object a user can construct has its own unique storage.</p>
<h2><a class="anchor" id="secarrays"></a>
Array container objects</h2>
<p>For convenience, the API provides array container classes with much limited facility compared to the Standard Template Library. In particular, one, two, three, and general <em>N</em> dimensional array container classes are available:</p>
<ul>
<li>multi1d</li>
<li>multi2d</li>
<li>multi3d</li>
<li>multiNd</li>
</ul>
<p>The benefit of two and higher dimension classes is that they can be allocated after they are declared. This is in contrast to the STL technique, which builds multi-dimensional arrays out of nested one-dimensional array, and one must allocate a nested array of array classes by looping over the individual elements allocating each one.</p>
<p>An array of container classes is constructed as follows:</p>
<pre class="fragment">multi1d&lt; QDP::LatticeComplex &gt; r(QDP::Nd); // a 1-D array of LatticeComplex 
multi2d&lt; QDP::Real &gt; foo(2,3);        // a 2-D array of Real with first index slowest
</pre><h2><a class="anchor" id="secfuncobj"></a>
Function objects</h2>
<p>Function objects are used in the constructions of Sets/subsets and maps/shifts. The objects created by maps are themselves function objects. They serve the role as functions, but because of their class structure can also carry state.</p>
<p>A function object has a struct/class declaration. The key part is the function call operator. A generic declaration is something like: </p>
<pre class="fragment">struct MyFunction
{
  MyFunction(int dir) : mu(dir) {}
  Real operator()(const int&amp; x)
    {\* operates on x using state held in mu and returns a Real *\}

  int mu;
}
</pre><p> A user can then use an object of type MyFunction like a function: % </p>
<pre class="fragment">MyFunction  foo(37); // hold 37 within foo
int x;
Real boo = foo(x);  // applies foo via operator()
</pre><h2><a class="anchor" id="subsets"></a>
Subsets</h2>
<p>It is sometimes convenient to partition the lattice into multiple disjoint subsets (e.g. time slices or checkerboards). Such subsets are defined through a user-supplied function that returns a range of integers 0 ,1, 2, ... , n-1, so that if <em>f(x) = i</em>, then site <em>x</em> is in partition <em>i</em>. A single subset may also be defined by limiting the range of return values to a single value (i.e. 0). This procedure may be called more than once, and sites may be assigned to more than one subset. Thus, for example an even site may also be assigned to a time slice subset and one of the subsets in a 32-level checkerboard scheme. A subset definition remains valid until is destructor is called.</p>
<p>The layout creation routine Layout::create() described in Section <a class="el" href="qdpfuncpage.html#secinit_qdp">Entry and exit from QDP</a> generates predefined lattice subsets for specifying even, odd, and global subsets of the lattice. The QDP::rb set can be dereferenced to produce the QDP::even and QDP::odd subsets:</p>
<p>QDP::Subset QDP::even, QDP::odd, QDP::all, QDP::rb[0], QDP::rb[1], QDP::mcb[0], ..., QDP::mcb[1 &lt;&lt; (QDP::Nd+1)]</p>
<dl class="section user"><dt>Defining a set</dt><dd></dd></dl>
<p>Subsets are first defined using a function object (see Section <a class="el" href="qdpfuncpage.html#secfuncobj">Function objects</a>) through the construction of an object of type OrderedSet or UnorderedSet whose parent type is Set. This function object is created from a function type of object SetFunc. The SetFunc operator returns the subset number to which a lattice site belongs. Subsets are defined through the parent data type Subset. There are two derived useable (concrete) types called UnorderedSubset and OrderedSubset. The latter type is an optimization that assumes (and run-time enforces) that the subset of sites for a given site layout must be contiguous. It is an error if they are not. Clearly, this assumption is layout dependent and is used mainly by the system wide supplied QDP::even, QDP::odd, <em>etc</em>. subsets under compile time flags. A general user subset should be declared to be UnorderedSubset. In both ordered and unordered subsets, they are constructed from the corresponding OrderedSet and UnorderedSet.</p>
<ul>
<li>OrderedSet::make(const SetFunc&amp; func)</li>
<li>UnorderedSet::make(const SetFunc&amp; func)</li>
<li>int SetFunc::operator()(const multi1d&lt;int&gt;&amp; x)</li>
<li>int SetFunc::numSubsets()</li>
</ul>
<p>These create a set based on the SetFunc that holds a number of subsets returned by SetFunc::numSubsets.</p>
<p>Here is an explicit example for a timeslice: </p>
<pre class="fragment">struct TimeSliceFunc : public SetFunc
{
  TimeSliceFunc(int dir): mu(dir) {}

  // Simply return the mu'th coordinate
  int operator()(const multi1d&lt;int&gt;&amp; coord)
  {return coord[mu];}

  // The number of subsets is the length of the lattice
  // in direction mu
  int numSubsets() {return Layout::lattSize()[mu];}

  int mu; // state
}
UnorderedSet timeslice;
timeslice.make(TimeSliceFunc(3)) // makes timeslice in direction 3
</pre><p>It is permissible to call UnorderedSet::make() with a function object having only 1 subset. In this case the partition function must return zero if the site is in the subset and nonzero if not. (Note, this is opposite to the "true", "false" convention in C).</p>
<dl class="section user"><dt>Extracting a subset</dt><dd></dd></dl>
<p>A subset is returned from indexing a UnorderedSet or OrderedSet object.</p>
<ul>
<li>OrderedSubset::operator[](int i)</li>
<li>UnorderedSubset::operator[](int i)</li>
</ul>
<p>return the <em>i</em>th subset from a Set object.</p>
<p>The Set::make() functions allocates all memory associated with a Set. A Subset holds a reference to the original Set. A destructor call on a Set frees all memory.</p>
<dl class="section user"><dt>Using a subset</dt><dd></dd></dl>
<p>A subset can be used in an assignment to restrict sites involved in a computation:</p>
<pre class="fragment">  LatticeComplex r, a, b;
  UnorderedSubset s;
  r[s] = 17 * a * b;
</pre><p>will multiply 17 * a * b only on sites in the subset s.</p>
<h2><a class="anchor" id="secshifts"></a>
Maps and shifts</h2>
<p>Shifts are general communication operations specified by any permutation of sites. Nearest neighbor shifts are a special case. Thus, for example,</p>
<pre class="fragment">  LatticeHalfFermion a, r;
  r[s] = shift(a,sign,dir);
</pre><p>shifts the QDP::LatticeHalfFermion half fermion field <em>a</em> along direction <em>dir</em>, forward or backward according to <em>sign</em>, placing the result in the field <em>r</em>. Nearest neighbor shifts are specified by values of <em>dir</em> in the range [0, N_d-1]. The sign is <em>+1</em> for shifts from the positive direction, and <em>-1</em> for shifts from the negative direction. That is, for <em> sign = +1 </em> and <em>dir</em> = <img class="formulaInl" alt="$\mu$" src="form_5.png"/> <img class="formulaInl" alt="$ r(x) = a(x+\hat \mu)$" src="form_6.png"/>. For more general permutations, <em>dir</em> is missing and <em>sign</em> specifies the permutation or its inverse.</p>
<p>The subset restriction applies to the destination field <em>r</em>. Thus a nearest neighbor shift operation specifying the even subset shifts odd site values from the source <em>a</em> and places them on even site values on the destination field <em>r</em>.</p>
<dl class="section user"><dt>Creating shifts for arbitrary permutations</dt><dd></dd></dl>
<p>The user must first create a function object for use in the map creation as described in Section <a class="el" href="qdpfuncpage.html#secfuncobj">Function objects</a>. Thus to use the make a map one uses a function object in the map creation:</p>
<ul>
<li>Map::make(const MapFunc&amp; func)</li>
</ul>
<p>Creates a map specified by the permutation map function object <em>func</em>. The <em>func</em> is a derived type of MapFunc and must have a multi1d&lt;int&gt; operator()(const multi1d&lt;int&gt;&amp; d) member function that maps a source site to <em>d</em>. It creates an object of type map which has a function call template&lt;class T&gt; T Map::operator()(const T&amp; a).</p>
<p>The coordinate map function object <em>func</em> above that is handed to the map creation function Map::make() maps lattice coordinates of the the destination to the source lattice coordinates. After construction, the function object of type Map can be used like any function via the operator(). It can be applied to all QDP objects in an expression.</p>
<p>The function object has an operator that given a coordinate will return the source site coordinates. An example is as follows:</p>
<pre class="fragment">struct naikfunc : public MapFunc
{
  naik(int dir) : mu(dir) {}
  multi1d&lt;int&gt; operator()(const multi1d&lt;int&gt;&amp; x)
    {\* maps x to x + 3*mu  where mu is direction vector *\}

  int mu;
}
</pre><p>For convenience, there are predefined Map functions named QDP::shift that can shift by 1 unit backwards or forwards in any lattice direction. They have the form</p>
<pre class="fragment">shift(const QDPType&amp; source, int sign, int dir);
</pre><p>The construction of a Map object allocates all the necessary memory needed for a shift. Similarly, a destructor call on a Map object frees memory.</p>
<h2><a class="anchor" id="tempentryexit"></a>
Temporary entry and exit from QDP</h2>
<p>For a variety of reasons it may be necessary to remove data from QDP structures. Conversely, it may be necessary to reinsert data into QDP structures. For example, a highly optimized linear solver may operate outside QDP. The operands would need to be extracted from QDP fields and the eventual solution reinserted. It may also be useful to suspend QDP communications temporarily to gain separate access to the communications layer. For this purpose function calls are provided to put the QDP implementation and/or QDP objects into a known state, extract values, and reinsert them.</p>
<dl class="section user"><dt>Extracting QDP data</dt><dd></dd></dl>
<p>Use</p>
<p>void QDP::QDP_extract(multi1d&lt;Type2&gt;&amp; dest, const Type1&amp; src, const Subset&amp; s)</p>
<p>to copy data values from field <em>src</em> to array <em>dest</em>, where</p>
<ul>
<li><em>Type1</em> is any lattice type</li>
<li><em>Type2</em> is any corresponding scalar lattice type</li>
</ul>
<p>The user must allocate the space of size Layout::sitesOnNode() for the destination array before calling this function, regardless of the size of the subset.</p>
<p>This function copies the data values contained in the QDP field <em>src</em> to the destination field. Only values belonging to the specified subset are copied. Any values in the destination array not associated with the subset are left unmodified. The order of the data is given by QDP::Layout::linearSiteIndex. Since a copy is made, QDP operations involving the source field may proceed without disruption.</p>
<dl class="section user"><dt>Inserting QDP data</dt><dd></dd></dl>
<p>Use void QDP::QDP_insert (Type1&amp; dest, const multi1d&lt;Type2&gt;&amp; src, const Subset&amp; s)</p>
<p>to insert data values from array <em>src</em>, where</p>
<ul>
<li><em>Type1</em> is any lattice type</li>
<li><em>Type2</em> any corresponding scalar lattice type</li>
</ul>
<p>Only data associated with the specified subset are inserted. Other values are unmodified. The data site order must conform to Layout::linearSiteIndex. This call, analogous to a fill operation, is permitted at any time and does not interfere with QDP operations.</p>
<dl class="section user"><dt>Suspending QDP communications</dt><dd></dd></dl>
<p>If a user wishes to suspend QDP communications temporarily and carry on communications by other means, it is first necessary to call QDP::QDP_suspend.</p>
<p>No QDP shifts can then be initiated until QDP::QDP_resume is called. However QDP linear algebra operations without shifts may proceed.</p>
<dl class="section user"><dt>Resuming QDP communications</dt><dd></dd></dl>
<p>To resume QDP communications one uses void QDP::QDP_resume() </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 23 2014 15:12:06 for QDP++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
