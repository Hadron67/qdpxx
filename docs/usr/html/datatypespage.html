<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>QDP++</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<style type="text/css"> code{ font-size: 130% } </style>
</head>
<body>
<center>
<b>QDP++  User Guide: &nbsp;</b>
<a class="qindex" href="index.html">Front Page</a> &nbsp;
<a class="qindex" href="intropage.html">Introduction</a> &nbsp;
<a class="qindex" href="datatypespage.html">Data Types</a> &nbsp;
<a class="qindex" href="qdpfuncpage.html">Functions</a> &nbsp;
<a class="qindex" href="simpleiopage.html">Simple IO</a> &nbsp;
<a class="qindex" href="qiopage.html">Record IO</a>&nbsp; 
<a class="qindex" href="buildpage.html">Compilation</a> &nbsp; 
<a class="qindex" href="spinpage.html">Spin Conventions</a> &nbsp; 
<a class="qindex" href="impldetail.html">Implementation</a> 
</center>
<hr>
<!-- Generated by Doxygen 1.8.2 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Data Types </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ol type="1">
<li><a class="el" href="datatypespage.html#typestructure">Type Structure</a></li>
<li><a class="el" href="datatypespage.html#genericnames">Generic Names</a></li>
<li><a class="el" href="datatypespage.html#colorprecisiontypes">Specific Types for Color and Precision</a></li>
<li><a class="el" href="datatypespage.html#colorprecisionuniform">Color and Precision Uniformity</a></li>
<li><a class="el" href="datatypespage.html#colorprecbreak">Breaking Color and Precision Uniformity</a></li>
</ol>
<h1><a class="anchor" id="datatypes"></a>
Datatypes in QDP</h1>
<p>The <em>N<sub>d</sub></em> dimensional lattice consists of all the space-time sites in the problem space. Lattice data are fields on these sites. A data primitive describes data on a single site. The lattice fields consist of the primitives over all sites. We do not define data types restricted to a subset of the lattice; rather, lattice fields occupy the entire lattice. The primitive types at each site are represented as the (tensor) product space of, for example, a vector space over color components with a vector space over spin components and complex valued elements.</p>
<h2><a class="anchor" id="typestructure"></a>
Type Structure</h2>
<p>Generically, objects transform under different spaces with a tensor product structure</p>
<p>Lattice <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Color <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Spin <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Complexity</p>
<p>as shown below:</p>
<ul>
<li>Gauge fields<ul>
<li>Lattice <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Matrix(Nc) <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Scalar <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Complex</li>
</ul>
</li>
<li>Fermions<ul>
<li>Lattice <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Vector(Nc) <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Vector(Ns) <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Complex</li>
</ul>
</li>
<li>Scalars<ul>
<li>Scalar <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Scalar <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Scalar <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Scalar</li>
</ul>
</li>
<li>Propagators<ul>
<li>Lattice <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Matrix(Nc) <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Matrix(Ns) <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Complex</li>
</ul>
</li>
<li>Gamma<ul>
<li>Scalar <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Scalar <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Matrix(Ns) <img class="formulaInl" alt="$\otimes$" src="form_0.png"/> Complex</li>
</ul>
</li>
</ul>
<p>where</p>
<ul>
<li>Nd is the number of space-time dimensions <em>N<sub>d</sub></em></li>
<li>Nc is the dimension of the color vector space <em>N<sub>c</sub></em></li>
<li>Ns is the dimension of the spin vector space <em>N<sub>s</sub></em></li>
</ul>
<p>Gauge fields can left-multiply fermions via color matrix times color vector but is diagonal in spin space (spin scalar times spin vector). A gamma matrix can right-multiply a propagator (spin matrix times spin matrix) but is diagonal in color space (color matrix times color scalar).</p>
<p>Types in the QDP interface are parameterized by a variety of types including:</p>
<ul>
<li><b>Word type:</b><ul>
<li>int, float, double, bool.</li>
<li>Basic machine types.</li>
</ul>
</li>
<li><b>Reality type:</b><ul>
<li>complex or scalar.</li>
<li>This is where the idea of a complex number lives.</li>
</ul>
</li>
<li><b>Primitive type:</b><ul>
<li>scalar, vector, matrix, etc.</li>
<li>This is where the concept of a gauge or spin field lives. There can be many more types here.</li>
</ul>
</li>
<li><b>Inner grid type:</b><ul>
<li>scalar or lattice.</li>
<li>Supports vector style architectures.</li>
</ul>
</li>
<li><b>Outer grid type:</b><ul>
<li>scalar or lattice.</li>
<li>Supports super-scalar style architectures. In combination with Inner grid can support a mixed mode like a super-scalar architecture with short length vector instructions.</li>
</ul>
</li>
</ul>
<p>There are template classes for each of the type variants listed above. The interface relies heavily on templates for composition - there is very little inheritance. The basic objects are constructed (at the user's choice) by compositions like the following:</p>
<pre class="fragment">typedef OLattice&lt;PScalar&lt;PColorMatrix&lt;RComplex&lt;float&gt;, Nc&gt; &gt; &gt; LatticeColorMatrix
typedef OLattice&lt;PSpinVector&lt;PColorVector&lt;RComplex&lt;float&gt;, Nc&gt;, Ns&gt; &gt; LatticeFermion
</pre><p>The classes PScalar, PSpinVector, PColorMatrix, PColorVector are all subtypes of a primitive type. The relative ordering of the classes is important. It is simply a user convention that spin is used as the second index (second level of type composition) and color is the third. The ordering of types can be changed. From looking at the types one can immediately decide what operations among objects makes sense.</p>
<h2><a class="anchor" id="genericnames"></a>
Generic Names</h2>
<p>The linear algebra portion of the QDP API is designed to resemble the functionality that is available in the Level 1 QLA API and the C Level QDP API. Thus the datatypes and function naming conventions are similar. Predefined names for some generic lattice field datatypes are listed in the table below. Because the API is based heavily on templates, the possible types allowed is much larger than listed below.</p>
<ul>
<li>QDP::LatticeReal : real</li>
</ul>
<ul>
<li>QDP::LatticeComplex :complex</li>
</ul>
<ul>
<li>QDP::LatticeInt : integer</li>
</ul>
<ul>
<li>QDP::LatticeColorMatrix : <em>N<sub>c</sub></em> x <em>N<sub>c</sub></em> complex matrix</li>
</ul>
<ul>
<li>QDP::LatticeFermion : <em>N<sub>s</sub></em> spin <em>N<sub>c</sub></em> color spinor</li>
</ul>
<ul>
<li>QDP::LatticeHalfFermion <em>N<sub>s</sub></em>/2 spin <em>N<sub>c</sub></em> color spinor</li>
</ul>
<ul>
<li>QDP::LatticeDiracFermion : 4 spin <em>N<sub>c</sub></em> color spinor</li>
</ul>
<ul>
<li>QDP::LatticeStaggeredFermion : 1 spin <em>N<sub>c</sub></em> color spinor</li>
</ul>
<ul>
<li>QDP::LatticeDiracPropagator : 4 <em>N<sub>c</sub></em> x 4 <em>N<sub>c</sub></em> complex matrix</li>
</ul>
<ul>
<li>QDP::LatticeStaggeredPropagator : <em>N<sub>c</sub></em> x <em>N<sub>c</sub></em> complex matrix</li>
</ul>
<p>Single site (lattice wide constant fields) versions of types exist without the <code>Lattice</code> preprended. All types and operations defined for QDP live within a C++ namespace called QDP, thus ensuring no type conflicts with other namespaces.</p>
<h2><a class="anchor" id="colorprecisiontypes"></a>
Specific Types for Color and Precision</h2>
<p>According to the chosen color and precision, names for specific floating point types are constructed from names for generic types. Thus QDP::LatticeColorMatrix becomes <em>LatticeColorMatrix<em>PC</em></em>, where the precision <em>P</em> is D or F according to the table below,</p>
 
<table>
<tr>
<th>Abbreviation</th><th>Description</th>
</tr>
<tr>
<td>D</td><td>double precision</td></tr>
<tr>
<td>F</td><td>single precision</td>
</tr>
</table>
<p>and C is 2, 3, or some arbitrary N, if color is a consideration. Note, the value of N is an arbitrary compile time constant.</p>
<p>If the datatype carries no color, the color label is omitted. Also, if the number of color components is the same as the compile time constant, then the color label can be omitted. Integers also have no precision label. The specification of precision and number of colors is not needed for functions because of overloading.</p>
<p>For example, the type QDP::LatticeDiracFermionF3 describes a lattice quantity of single-precision four-spin, three-color spinor field.</p>
<h2><a class="anchor" id="colorprecisionuniform"></a>
Color and Precision Uniformity</h2>
<p>The only place that the number of color or spin components occur is through instance of the global constant variables QDP::Nc and QDP::Ns. These are only directly used in the typedef constructions of user defined types. Nothing restricts a user from constructing types for other number of colors. In fact, the use of QDP::Nc in the construction of user defined types is simply a convenience for the user, and as such a user can use any integer that is reasonable. The API merely requires that the types used in operations are conforming.</p>
<p>However, in standard coding practice it is assumed that a user keeps one of the precision, color, and spin options in force throughout the compilation. So as a rule all functions in the interface take operands of the same precision, color, and number of spin components. As with data type names, function names come in generic color-, spin- and precision-specific forms, as described in the next section. Exceptions to this rule are functions that explicitly convert from double to single precision and vice versa. If the user choose to adopt color and precision uniformity, then all variables can be defined with generic types and all functions accessed through generic names. The prevailing color <em>N<sub>c</sub></em> is defined through the compile time constant QDP::Nc. The interface automatically translates data type names and function names to the appropriate specific type names through typedefs. With such a scheme and careful coding, changing only the compile time <em>N<sub>c</sub></em> and the QDP library converts code from one color and precision choice to another.</p>
<h2><a class="anchor" id="colorprecbreak"></a>
Breaking Color and Precision Uniformity</h2>
<p>It is permissible for a user to mix precision and color choices. This is done by declaring variables with specific type names, using functions with specific names, and making appropriate precision conversions when needed. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 23 2014 15:12:06 for QDP++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
