<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>QDP++</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<style type="text/css"> code{ font-size: 130% } </style>
</head>
<body>
<center>
<b>QDP++  User Guide: &nbsp;</b>
<a class="qindex" href="index.html">Front Page</a> &nbsp;
<a class="qindex" href="intropage.html">Introduction</a> &nbsp;
<a class="qindex" href="datatypespage.html">Data Types</a> &nbsp;
<a class="qindex" href="qdpfuncpage.html">Functions</a> &nbsp;
<a class="qindex" href="simpleiopage.html">Simple IO</a> &nbsp;
<a class="qindex" href="qiopage.html">Record IO</a>&nbsp; 
<a class="qindex" href="buildpage.html">Compilation</a> &nbsp; 
<a class="qindex" href="spinpage.html">Spin Conventions</a> &nbsp; 
<a class="qindex" href="impldetail.html">Implementation</a> 
</center>
<hr>
<!-- Generated by Doxygen 1.8.2 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">I/O utilities </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="secsimpleio"></a>
Simple I/O utilities</h1>
<ol type="1">
<li><a class="el" href="simpleiopage.html#basicio">Basic structure</a></li>
<li><a class="el" href="simpleiopage.html#textio">Text Reading and Writing</a></li>
<li><a class="el" href="simpleiopage.html#secxmlio">XML Reading and Writing</a></li>
<li><a class="el" href="simpleiopage.html#secxmldoc">XML document structure</a></li>
<li><a class="el" href="simpleiopage.html#secbinaryio">Binary Reading and Writing</a></li>
</ol>
<h2><a class="anchor" id="basicio"></a>
Basic structure</h2>
<p>There are three main types of user accessible classes for simple file I/O - Text, XML and Binary. For each of these classes there is a Reader and a Writer version. Each support I/O for <em>any</em> QDP defined scalar and lattice quantity as well as the standard C++ builtin types like <code>int</code> and <code>float</code>. These classes all read/write to/from one primary node in the computer, namely Layout::primaryNode() or node 0. Lattice quantities are read/written lexicographically as one contiguous field with the first index in the lattice size Layout::lattSize() varying the fastest. The XML reader functions utilize C++ exceptions</p>
<p>See io in the Reference Manual for the complete listing.</p>
<p>A record structure format is available to store both metadata and binary data. The metadata uses the XML format. The binary I/O functions support more advanced I/O mechanisms and is described in <a class="el" href="qiopage.html#secqio">QDP Record I/O utilities</a>.</p>
<p>The C++ standard IO streams <code>cout</code>, <code>cerr</code> and <code>cin</code> are, of course, provided by the language but may not work as expected. Namely, the output functions will write on all nodes, and <code>cin</code> will try to read from all nodes and fail. QDP predefined global objects QDPIO::cout, QDPIO::cerr, and QDPIO::cin are provided as replacements and will wbrite/read from only the primary node. Output can be selected from any 1 or all nodes for debugging. The QDP implementation does not destroy the standard IO streams.</p>
<h2><a class="anchor" id="textio"></a>
Text Reading and Writing</h2>
<p>The global predefined objects QDPIO::cout, QDPIO::cerr, and QDPIO::cin are used like their C++ standard IO streams counterparts. All QDP scalar site fields (e.g., non-lattice) fields can be read and written with these streams. For example, one can read data and be assured the data is appropriately distributed to all nodes.</p>
<p>For example:</p>
<pre class="fragment">multi1d&lt;int&gt; my_array(4);                            
QDPIO::cin &gt;&gt; my_array;  // broadcasted to all nodes 
QDP::Real x;                                         
random(x); 
QDPIO::cout &lt;&lt; "QDP is GREAT: x = " &lt;&lt; x &lt;&lt; std::endl; // one copy on output
</pre><p>The default behavior is for only the primary node to print on output. Also provided are C++ Standard Library-like IO manipulators that can be used to change this behavior. Namely, IO can be directed from any node which can aid debugging. </p>
<dl class="section note"><dt>Note</dt><dd>IO manipulators for changing node output are not yet implemented.</dd></dl>
<dl class="section user"><dt>TextReader member functions and global functions</dt><dd></dd></dl>
<ul>
<li>Open to read<ul>
<li>TextReader::TextReader(const std::string&amp; filename)</li>
<li>void TextReader::open(const std::string&amp; filename)</li>
</ul>
</li>
<li>Close<ul>
<li>TextReader::~TextReader()</li>
<li>void TextReader::close()</li>
</ul>
</li>
<li>Open?<ul>
<li>bool TextReader::is_open()</li>
</ul>
</li>
<li>Any IO errors?<ul>
<li>bool TextReader::fail()</li>
</ul>
</li>
<li>Input a type <em>T</em> <ul>
<li>TextReader&amp; operator&gt;&gt;(TextReader&amp;, T&amp;)</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>TextWriter member functions and global functions</dt><dd></dd></dl>
<ul>
<li>Open to write<ul>
<li>TextWriter::TextWriter(const std::string&amp; filename)</li>
<li>void TextWriter::open(const std::string&amp; filename)</li>
</ul>
</li>
<li>Close<ul>
<li>TextWriter::~TextWriter()</li>
<li>void TextWriter::close()</li>
</ul>
</li>
<li>Open?<ul>
<li>bool TextWriter::is_open()</li>
</ul>
</li>
<li>Any IO errors?<ul>
<li>bool TextWriter::fail()</li>
</ul>
</li>
<li>Output a type <em>T</em> <ul>
<li>TextWriter&amp; operator&lt;&lt;(TextWriter&amp;, const T&amp;)</li>
</ul>
</li>
</ul>
<p>To read and write ASCII text from the file, use the standard operators familiar in the C++ Standard Library. An example is as follows:</p>
<pre class="fragment">TextWriter out("foo");
Real a = 1.2;
Complex b = cmplx(Real(-1.1), Real(2.2));
out &lt;&lt; a &lt;&lt; endl &lt;&lt; b &lt;&lt; endl;
close(out);

TextReader in("foo");
Real a;
Complex b;
in &gt;&gt; a &gt;&gt; b;
close(in);
</pre><p>The TextWriter functions would produce a file "foo" that looks like </p>
<pre class="fragment">1.2
-1.1 2.2
</pre><h2><a class="anchor" id="secxmlio"></a>
XML Reading and Writing</h2>
<p>XML is intended as the standard format for user produced human readable data as well as metadata. The XML format is always a tree of tag/value pairs with arbitrarily deep nesting. Here, the tags are variable names. The values are considered one of three types &ndash; a simple type, a structure, or an array of one of these types, including an array of arrays.</p>
<p>The XML reader functions utilize C++ exceptions.</p>
<p>The path specification for the XML reader functions is XPath. Namely, QDP only requires a simple UNIX-like path to reference a tag. With a simple path and nested reading, all data can be read from a document. However, more complicated queries are possible allowing the user to read individual pieces of a document - e.g., a single array element. See the XPath language specification at <a href="http://www.w3.org/TR/xpath.html">http://www.w3.org/TR/xpath.html</a> for additional information.</p>
<p>Further details on the document format of various types is given in <a class="el" href="simpleiopage.html#secxmldoc">XML document structure</a>.</p>
<dl class="section user"><dt>XMLReader member functions and global functions</dt><dd></dd></dl>
<ul>
<li>Read file<ul>
<li>XMLReader::XMLReader(const std::string&amp;)</li>
<li>void XMLReader::open(const std::string&amp;)</li>
</ul>
</li>
<li>Read stream<ul>
<li>XMLReader::XMLReader(std::istream&amp;)</li>
<li>void XMLReader::open(std::istream&amp;)</li>
</ul>
</li>
<li>Read buffer<ul>
<li>XMLReader::XMLReader(const XMLBufferWriter&amp;)</li>
<li>void XMLReader::open(const XMLBufferWriter&amp;)</li>
</ul>
</li>
<li>Close<ul>
<li>XMLReader::~XMLReader()</li>
<li>void X LReader::close()</li>
</ul>
</li>
<li>Open?<ul>
<li>bool XMLReader::is_open()</li>
</ul>
</li>
<li>Input a type T<ul>
<li>void QDP::read (XMLReader&amp;, const std::string&amp;, T&amp;)</li>
</ul>
</li>
</ul>
<p>An example of reading a file is</p>
<pre class="fragment">XMLReader xml_in("foo");
int a;
Complex b;
multi1d&lt;Real&gt; c;
multi1d&lt;Complex&gt; d;
read(xml_in, "/bar/a", a);  // primitive type reader
read(xml_in, "/bar/b", b);  // QDP defined struct reader
read(xml_in, "/bar/c", d);  // array of primitive type reader
try {   // try to do the following code, if an exception catch it
  read(xml_in, "/bar/d", d);  // calls read(XMLReader, string, Complex) 
} catch( const string&amp; error) { 
  cerr &lt;&lt; "Error reading /bar/d : " &lt;&lt; error &lt;&lt; endl;
}
</pre><p>The file "foo" might look like the following:</p>
<pre class="fragment">&lt;?xml version="1.0"?&gt;
&lt;bar&gt;
 &lt;!-- A simple primitive type --&gt;
 &lt;a&gt;17&lt;/d&gt;

 &lt;!-- Considered a structure --&gt;
 &lt;b&gt;
   &lt;re&gt;1.0&lt;/re&gt;
   &lt;im&gt;2.0&lt;/im&gt;
 &lt;/b&gt;

 &lt;!-- A length 3 array of primitive types --&gt;
 &lt;c&gt;1 5.6 7.2&lt;/c&gt;

 &lt;!-- A length 2 array of non-simple types --&gt;
 &lt;d&gt;
   &lt;elem&gt;
     &lt;re&gt;1.0&lt;/re&gt;
     &lt;im&gt;2.0&lt;/im&gt;
   &lt;/elem&gt;
   &lt;elem&gt;
     &lt;re&gt;3.0&lt;/re&gt;
     &lt;im&gt;4.0&lt;/im&gt;
   &lt;/elem&gt;
 &lt;/d&gt;
&lt;/bar&gt;
</pre><p>Users can define their own reader functions following the same overloaded syntax as the predefined ones. This allows one to nest readers.</p>
<pre class="fragment">struct MyStruct {int a; Real b;};

void read(XMLReader&amp; xml_in, const string path&amp;, MyStruct&amp; input)
{
  read(xml_in, path + "/a", input.a);
  read(xml_in, path + "/b", input.b);
}

XMLReader xml_in;  // user should initialize here
multi1d&lt;MyStruct&gt; foo;  // array size will be allocated in array reader
read(xml_in, "/root", foo); // will call user defined read above for each element
</pre><p>As stated before, the path specification for a read is actually an XPath query. For example, the user can read only one array element in the file "foo" above via an XPath query:</p>
<pre class="fragment">XMLReader xml_in("foo");
Complex dd;
read(xml_in, "/bar/d/elem[2]", dd);  // read second array elem of d, e.g. d[1]
</pre><dl class="section user"><dt>XMLWriter base class global functions</dt><dd></dd></dl>
<ul>
<li>Start a group<ul>
<li>void push(XMLWriter&amp;, const std::string&amp; name)</li>
</ul>
</li>
<li>End a group<ul>
<li>void pop(XMLWriter&amp;)</li>
</ul>
</li>
<li>Output a T<ul>
<li>void write(XMLWriter&amp;, const std::string&amp; path, const T&amp;)</li>
</ul>
</li>
<li>Output<ul>
<li>void write(XMLWriter&amp;, const std::string&amp; path, const XMLBufferWriter&amp;)</li>
<li>XMLWriter&amp; operator&lt;&lt;(XMLWriter&amp;, const XMLBufferWriter&amp;)</li>
<li>void write(XMLWriter&amp;, const std::string&amp; path, const XMLReader&amp;)</li>
<li>XMLWriter&amp; operator&lt;&lt;(XMLWriter&amp;, const XMLReader&amp;)</li>
</ul>
</li>
</ul>
<p>The XMLWriter is an abstract base class for three concrete classes which allow to write into a memory buffer, a file, or write an array of objects in a series of steps.</p>
<dl class="section user"><dt>XMLBufferWriter derived class member functions</dt><dd></dd></dl>
<ul>
<li>Return entire buffer<ul>
<li>std::string XMLBufferWriter::str()</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>XMLFileWriter derived class member functions</dt><dd></dd></dl>
<ul>
<li>File to write<ul>
<li>XMLFileWriter::XMLFileWriter(const std::string&amp; filename)</li>
<li>void XMLFileWriter::open(const string&amp; std::filename)</li>
</ul>
</li>
<li>Close<ul>
<li>XMLFileWriter::~XMLFileWriter()</li>
<li>void XMLFileWriter::close()</li>
</ul>
</li>
<li>Open?<ul>
<li>bool XMLFileWriter::is_open()</li>
</ul>
</li>
<li>Any IO errors?<ul>
<li>bool XMLFileWriter::fail()</li>
</ul>
</li>
<li>Flush<ul>
<li>void XMLFileWriter::flush()</li>
</ul>
</li>
</ul>
<p>Similar to the read case, the user can also create a tower of writer functions. In addition, the user can create memory held buffered output that can be used for metadata. Similarly, a user can go back and forth from readers to writers.</p>
<pre class="fragment">XMLBufferWriter xml_buf;
push(xml_buf, "bar");
write(xml_buf, "a", 1);  // write /bar/a = 1
pop(xml_buf);

XMLReader xml_in(xml_buf);  // re-parse the xml_buf
int a;
read(xml_in, "/bar/a", a); // now have 1 in a

XMLFileWriter xml_out("foo");
xml_out &lt;&lt; xml_in;     // will have ``bar'' as the root tag
xml_out.close();
</pre><dl class="section user"><dt>XMLArrayWriter derived class member and global functions</dt><dd></dd></dl>
<ul>
<li>Constructor<ul>
<li>XMLArrayWriter::XMLArrayWriter(XMLWriter&amp;, int size=-1)</li>
</ul>
</li>
<li>Close<ul>
<li>XMLArrayWriter::~XMLArrayWriter()</li>
<li>void XMLArrayWriter::close()</li>
</ul>
</li>
<li>Size<ul>
<li>int XMLArrayWriter::size()</li>
</ul>
</li>
<li>Start an array<ul>
<li>void push(XMLArrayWriter&amp;)</li>
</ul>
</li>
<li>End an array<ul>
<li>void pop(XMLArrayWriter&amp;)</li>
</ul>
</li>
</ul>
<p>The Array class allows one to break writing an array into multiple pieces:</p>
<pre class="fragment">XMLFileWriter xml_out("foo");
XMLArrayWriter xml_array(xml_out, 350000);  // Note: a big array size here
push(xml_array, "the_name_of_my_array");
for(int i=0; i &lt; xml_array.size(); ++i)
{
  push(xml_array);  // start next array element - name of tag already defined
  Real foo = i;
  write(xml_array, "foo", foo);
  pop(xml_array);   // finish this array element
}
</pre><h3><a class="anchor" id="arrayio"></a>
Using Array Containers in Reading and Writing}</h3>
<p>Array sizes present a special problem in IO. However, within XML the QDP::read (XMLReader&amp;, std::string path, multi1d&lt;T&gt;&amp;) function can deduce the number of elements an array is expected to hold and will always resize the array to the appropriate size. Hence, there is no need to record the array size in the output of a QDP::write (XMLWriter&amp;, std::string path, const multi1d&lt;T&gt;&amp;) function call since the corresponding read can deduce the size.</p>
<p>This behavior is unlike the BinaryReader and BinaryWriter functions QDP::read and QDP::write of multi1d. There, the length of the array is always read/written unless the C-like behavior varieties are used.</p>
<h2><a class="anchor" id="secxmldoc"></a>
XML document structure</h2>
<p>QDP regards the structure of a document as composed of structures, simple types, or arrays of structures or simple types. Simple types are the usual built-in type of C and C++, namely <code>int</code>, <code>float</code>, <code>double</code>, <code>bool</code>, etc. In addition, the QDP scalar equivalents QDP::Integer, QDP::Real, QDP::Double, QDP::Boolean, etc. are also consider simple types. For instance, the code snippet</p>
<pre class="fragment">int a = 3;
write(xml_out, "a", a);
</pre><p> would produce </p>
<pre class="fragment">&lt;a&gt;3&lt;/a&gt;
</pre><p> indentities the name of a variable of a type with some values. Following the XML Schema specifications, arrays of these simple types have a simple form </p>
<pre class="fragment">&lt;!-- produced from writing a multid&lt;int&gt; --&gt;
&lt;a&gt;3 3 4 5&lt;/a&gt;
</pre><p>Again, following the XML Schema specifications all other objects are considered complex (e.g., complicated) types. Hence, the document snippet % </p>
<pre class="fragment">&lt;?xml version="1.0"?&gt;
&lt;!-- Considered a structure of simple types, arrays and other structures --&gt;
&lt;bar&gt;
 &lt;!-- A simple primitive type --&gt;
 &lt;a&gt;17&lt;/d&gt;

 &lt;!-- Considered a structure --&gt;
 &lt;b&gt;
   &lt;re&gt;1.0&lt;/re&gt;
   &lt;im&gt;2.0&lt;/im&gt;
 &lt;/b&gt;

 &lt;!-- A length 3 array of primitive types --&gt;
 &lt;c&gt;1 5.6 7.2&lt;/c&gt;
</pre><p>is viewed as a structure of other types: </p>
<pre class="fragment">struct bar_t
{
  int a;
  Complex b;
  multi1d&lt;Real&gt; c;
} bar;
</pre><p>Hence, one views the QDP::push / QDP::pop semantics as a way of dynamically constructing structures.</p>
<dl class="section user"><dt>XML document format</dt><dd></dd></dl>
<ul>
<li>QDP::Int, QDP::Real, QDP::Double<ul>
<li><pre class="fragment">&lt;a&gt;3&lt;/a&gt; </pre></li>
</ul>
</li>
<li>QDP::Boolean<ul>
<li><pre class="fragment">&lt;a&gt;yes&lt;/a&gt; </pre></li>
</ul>
</li>
<li>string<ul>
<li><pre class="fragment">&lt;a&gt;hello world&lt;/a&gt; </pre></li>
</ul>
</li>
<li>multi1d&lt;int&gt;<ul>
<li><pre class="fragment">&lt;a&gt;1 2 3&lt;/a&gt; </pre></li>
</ul>
</li>
<li>QDP::Complex<ul>
<li><pre class="fragment">&lt;a&gt;  
   &lt;re&gt;1.2&lt;/re&gt;  
   &lt;im&gt;2.0&lt;/im&gt;  
&lt;/a&gt; </pre></li>
</ul>
</li>
<li>multi1d&lt;Type&gt;<ul>
<li><pre class="fragment">&lt;a&gt;
  &lt;elem&gt; Type &lt;/elem&gt;
  &lt;elem&gt; Type &lt;/elem&gt;
&lt;/a&gt;
</pre></li>
</ul>
</li>
<li>multi1d&lt;Complex&gt;<ul>
<li><pre class="fragment">&lt;a&gt;
  &lt;elem&gt;
    &lt;re&gt;1.2&lt;/re&gt;
    &lt;im&gt;2.0&lt;/im&gt;
  &lt;/elem&gt;
  &lt;elem&gt;
    &lt;re&gt;3&lt;/re&gt;
    &lt;im&gt;5.0&lt;/im&gt;
  &lt;/elem&gt;
&lt;/a&gt;
</pre></li>
</ul>
</li>
<li>QDP::ColorVector<ul>
<li><pre class="fragment">&lt;a&gt;
  &lt;ColorVector&gt;
    &lt;elem row="0"&gt;
      &lt;re&gt;0&lt;/re&gt;
      &lt;im&gt;1&lt;/im&gt;
    &lt;/elem&gt;
    &lt;elem row="1"&gt;
      &lt;re&gt;2&lt;/re&gt;
      &lt;im&gt;3&lt;/im&gt;
    &lt;/elem&gt;
  ...
  &lt;/ColorVector&gt;
&lt;/a&gt;
</pre></li>
</ul>
</li>
<li>QDP::ColorMatrix<ul>
<li><pre class="fragment">&lt;a&gt;
  &lt;ColorMatrix&gt;
    &lt;elem row="0" col="0"&gt;
      &lt;re&gt;0&lt;/re&gt;
      &lt;im&gt;1&lt;/im&gt;
    &lt;/elem&gt;
    &lt;elem row="1" col="0"&gt;
      &lt;re&gt;2&lt;/re&gt;
      &lt;im&gt;3&lt;/im&gt;
    &lt;/elem&gt;
  ...
  &lt;/ColorMatrix&gt;
&lt;/a&gt;
</pre></li>
</ul>
</li>
<li>QDP::DiracPropagatorD, QDP::DiracPropagatorF, <em>etc</em>.<ul>
<li><pre class="fragment">&lt;a&gt;
  &lt;SpinMatrix&gt;
    &lt;elem row="0" col="0"&gt;
      &lt;ColorMatrix&gt;
        &lt;elem row="0" col="0"&gt;
          &lt;re&gt;0&lt;/re&gt;
          &lt;im&gt;1&lt;/im&gt;
        &lt;/elem&gt;
  ...
      &lt;/ColorMatrix&gt;
    &lt;/elem&gt;
  &lt;/SpinMatrix&gt;
&lt;/a&gt;
</pre></li>
</ul>
</li>
<li>OLattice, QDP::OLattice&lt;Type&gt; <pre class="fragment">&lt;a&gt;
  &lt;OLattice&gt;
    &lt;elem site="0"&gt; Type &lt;/elem&gt;
    &lt;elem site="1"&gt; Type &lt;/elem&gt;
    ...
  &lt;/OLattice&gt;
&lt;/a&gt;
</pre></li>
<li>QDP::LatticeReal<ul>
<li><pre class="fragment">&lt;a&gt;
  &lt;OLattice&gt;
    &lt;elem site="0"&gt;1
    &lt;/elem&gt;
    &lt;elem site="1"&gt;2
    &lt;/elem&gt;
  ...
  &lt;/OLattice&gt;
&lt;/a&gt;
</pre></li>
</ul>
</li>
<li>QDP::LatticeColorVector<ul>
<li><pre class="fragment">&lt;a&gt;
  &lt;OLattice&gt;
    &lt;elem site="0"&gt;
      &lt;ColorVector&gt;
        &lt;elem row="0"&gt;
           &lt;re&gt;1&lt;/re&gt;
           &lt;im&gt;2&lt;/im&gt;
        &lt;/elem&gt;
  ...
      &lt;/ColorVector&gt;
    &lt;/elem&gt;
  &lt;/OLattice&gt;
&lt;/a&gt;
</pre></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="secbinaryio"></a>
Binary Reading and Writing</h2>
<dl class="section user"><dt>BinaryReader member functions and global functions</dt><dd></dd></dl>
<ul>
<li>Open to read<ul>
<li>BinaryReader::BinaryReader(const std::string&amp; filename)</li>
<li>void BinaryReader::open(const std::string&amp; filename)</li>
</ul>
</li>
<li>Close<ul>
<li>BinaryReader::~BinaryReader()</li>
<li>void BinaryReader::close()</li>
</ul>
</li>
<li>Open?<ul>
<li>bool BinaryReader::is_open()</li>
</ul>
</li>
<li>Any IO errors?<ul>
<li>bool BinaryReader::fail()</li>
</ul>
</li>
<li>Input a type T<ul>
<li>BinaryReader&amp; operator&gt;&gt;(BinaryReader&amp;, T&amp;)</li>
<li>void read(BinaryReader&amp;, T&amp;)</li>
<li>void read(BinaryReader&amp;, multi1d&lt;T&gt;&amp;)</li>
<li>void read(BinaryReader&amp;, multi1d&lt;T&gt;&amp;, int num)</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>BinaryWriter member functions and global functions</dt><dd></dd></dl>
<ul>
<li>Open to write<ul>
<li>BinaryWriter::BinaryWriter(const std::string&amp; filename)</li>
<li>void BinaryWriter::open(const std::string&amp; filename)</li>
</ul>
</li>
<li>Close<ul>
<li>BinaryWriter::~BinaryWriter()</li>
<li>void BinaryWriter::close()</li>
</ul>
</li>
<li>Open?<ul>
<li>bool BinaryWriter::is_open()</li>
</ul>
</li>
<li>Any IO errors?<ul>
<li>bool BinaryWriter::fail()</li>
</ul>
</li>
<li>Flush<ul>
<li>bool BinaryWriter::flush()</li>
</ul>
</li>
<li>Output a type T<ul>
<li>BinaryWriter&amp; operator&lt;&lt;(BinaryWriter&amp;, const T&amp;)</li>
<li>void write(BinaryWriter&amp;, const T&amp;)</li>
<li>void write(BinaryWriter&amp;, const multi1d&lt;T&gt;&amp;)</li>
<li>void write(BinaryWriter&amp;, const multi1d&lt;T&gt;&amp;, int num)</li>
</ul>
</li>
</ul>
<p>To read and write ASCII text from the file, use the standard operators familiar in the C++ Standard Library, e.g.,</p>
<pre class="fragment">BinaryWriter out("foo");
Real a;
LatticeColorMatrix b
write(out, a);  // can write this way
out &lt;&lt; b;       // or can write this way - have choice of style
close(out);

BinaryReader in("foo");
Real a;
LatticeColorMatrix b;
read(in, a);
in &gt;&gt; b;
close(in);
</pre><p>The QDP::read and QDP::write functions using BinaryReader and BinaryWriter are special since metadata (in this case the length of the array) is read/written along with an object of type multi1d.</p>
<p>The standard C behavior when writing an array is to write only whatever number of elements is specified. The problem comes when reading with the number of elements is no known beforehand. The default QDP::write behavior is to also write the number of elements, and the QPD::read expects to find this length. The standard C behavior (reading/writing a fixed number of elements) is obtained through an an explicit argument to the call. Specifically:</p>
<pre class="fragment">BinaryWriter out("foo");
multi1d&lt;Real&gt; a(17);
write(out, a);     // will write an int=a.size() along with a.size() Real elements
write(out, a, 4);  // only writes 4  Real  elements 
close(out);

BinaryReader in("foo");
multi1d&lt;Real&gt; a;
read(in, a);  // reads an int=a.size(), a is resized, and reads a.size() elements
read(in, a, 4);  // reads precisely 4 elements, no resizing.
in &gt;&gt; b;
close(in);
</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 23 2014 15:12:06 for QDP++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
